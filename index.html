<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="叶子冲冲冲">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="叶子冲冲冲">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="叶子">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>叶子冲冲冲</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">叶子冲冲冲</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">相信你，你可以的</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/25/%E8%8B%8F%E8%BD%BC%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/25/%E8%8B%8F%E8%BD%BC%E9%9B%86/" itemprop="url">苏轼集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-25T17:23:49+01:00">
                2021-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%97%E8%AF%8D/" itemprop="url" rel="index">
                    <span itemprop="name">诗词</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浣溪沙-元丰七年十二月二十四日从泗州刘倩叔游南山"><a href="#浣溪沙-元丰七年十二月二十四日从泗州刘倩叔游南山" class="headerlink" title="浣溪沙 元丰七年十二月二十四日从泗州刘倩叔游南山"></a>浣溪沙 元丰七年十二月二十四日从泗州刘倩叔游南山</h2><blockquote>
<p>细雨斜风作晓寒，</p>
<p>淡烟疏柳媚晴滩，</p>
<p>入淮清洛渐漫漫。</p>
</blockquote>
<blockquote>
<p>雪沫乳花浮午盏，</p>
<p>蓼茸蒿笋试春盘，</p>
<p>人间有味是清欢</p>
</blockquote>
<h3 id="江城子-乙卯正月二十日夜记梦"><a href="#江城子-乙卯正月二十日夜记梦" class="headerlink" title="江城子 乙卯正月二十日夜记梦"></a>江城子 乙卯正月二十日夜记梦</h3><blockquote>
<p>十年生死两茫茫，</p>
<p>不思量，</p>
<p>自难忘。</p>
<p>千里孤坟，</p>
<p>无处话凄凉。</p>
<p>纵使相逢应不识，</p>
<p>尘满面，</p>
<p>鬓如霜。</p>
</blockquote>
<blockquote>
<p>夜来幽梦忽还乡，</p>
<p>小轩窗，</p>
<p>正梳妆。</p>
<p>相顾无言，</p>
<p>惟有泪千行。</p>
<p>料得年年断肠处，</p>
<p>明月夜，</p>
<p>短松岗。</p>
</blockquote>
<h3 id="行香子-述怀"><a href="#行香子-述怀" class="headerlink" title="行香子 述怀"></a>行香子 述怀</h3><blockquote>
<p> 清夜无尘，</p>
<p>月色如银。</p>
<p>酒斟时，</p>
<p>须满十分。</p>
<p>浮名浮利，</p>
<p>虚苦劳神。</p>
<p>叹隙中驹，石中火，梦中身。</p>
</blockquote>
<blockquote>
<p>虽抱文章，</p>
<p>开口谁亲。</p>
<p>且陶陶，</p>
<p>乐尽天真。</p>
<p>几时归去，</p>
<p>做个闲人。</p>
<p>对一张琴，一壶酒，一溪云。</p>
</blockquote>
<h3 id="西江月-中秋和子由"><a href="#西江月-中秋和子由" class="headerlink" title="西江月 中秋和子由"></a>西江月 中秋和子由</h3><blockquote>
<p>世事一场大梦，</p>
<p>人生几度秋凉。</p>
<p>夜来风叶已鸣廊。</p>
<p>看取眉头鬓上。</p>
</blockquote>
<blockquote>
<p>酒贱常客少，</p>
<p>月明多云妨。</p>
<p>中秋谁与孤光。</p>
<p>把盏凄然北望</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/16/spring%20react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/16/spring%20react/" itemprop="url">spring react</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-16T11:19:52+01:00">
                2020-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-Reactor"><a href="#Spring-Reactor" class="headerlink" title="Spring Reactor"></a>Spring Reactor</h1><h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p><strong>Reactor 框架</strong>实现了Reactive Programming思想，符合<strong>Reactive Streams规范</strong>。</p>
<h2 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h2><table>
<thead>
<tr>
<th>event</th>
<th>Iterable (pull)</th>
<th>Observable (push)</th>
</tr>
</thead>
<tbody><tr>
<td>retrieve data</td>
<td><code>T next()</code></td>
<td><code>onNext(T)</code></td>
</tr>
<tr>
<td>discover error</td>
<td>throws <code>Exception</code></td>
<td><code>onError(Exception)</code></td>
</tr>
<tr>
<td>complete</td>
<td><code>!hasNext()</code></td>
<td><code>onCompleted()</code></td>
</tr>
</tbody></table>
<p>上面表格的中的 Observable 那一列便代表反应式编程的 API 使用方式。可见，它就是常见的<strong>观察者模式的一种延伸。</strong></p>
<p>被订阅者（Publisher）主动的推送数据给订阅者（Subscriber），触发 <code>onNext</code> 方法。异常和完成时触发另外两个方法。如果 <u>Publisher 发布消息太快了，超过了 Subscriber 的处理速度</u>，那怎么办。这就是 <strong>Backpressure</strong> 的由来，Reactive Programming 框架需要提供机制，<u>使得 Subscriber 能够控制消费消息的速度。</u></p>
<p>在 Java 平台上，Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定了一个被称为 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Freactive-streams%2Freactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams 项目（规范）</a>，用于<strong>制定反应式编程相关的规范以及接口</strong>。其主要的接口有这三个：</p>
<ul>
<li><code>Publisher</code></li>
<li><code>Subscriber</code></li>
<li><code>Subcription</code></li>
</ul>
<p>其中，<code>Subcriber</code> 中便包含了上面表格提到的 <code>onNext</code>、<code>onError</code>、<code>onCompleted</code> 这三个方法。</p>
<h2 id="Imperative-vs-Reactive"><a href="#Imperative-vs-Reactive" class="headerlink" title="Imperative vs Reactive"></a>Imperative vs Reactive</h2><p>Imperatice = Iterable, Reactive = Observable. 是拉模型和推模型的另一种表述，</p>
<p>Imperative, 指令式编程，常见风格，代码执行顺序和编写顺序基本一致（这里不考虑 JVM 指令重排）</p>
<h2 id="Reactor-的主要模块"><a href="#Reactor-的主要模块" class="headerlink" title="Reactor 的主要模块"></a>Reactor 的主要模块</h2><p>Reactor 框架主要有两个主要的模块：<strong>reactor-core</strong> 和 <strong>reactor-ipc</strong>。前者主要负责 Reactive Programming 相关的<strong>核心 API</strong> 的实现，后者负责<strong>高性能网络通信</strong>的实现，目前是<strong>基于 Netty</strong> 实现的。</p>
<h2 id="Reactor-的主要类"><a href="#Reactor-的主要类" class="headerlink" title="Reactor 的主要类"></a>Reactor 的主要类</h2><p>在 Reactor 中，经常使用的类主要有以下两个：</p>
<ul>
<li><code>Mono</code> 实现了 <code>org.reactivestreams.Publisher</code> 接口，代表0到1个元素的发布者。</li>
<li><code>Flux</code> 同样实现了 <code>org.reactivestreams.Publisher</code> 接口，代表0到N个元素的发布者。</li>
</ul>
<h2 id="Web-Flux"><a href="#Web-Flux" class="headerlink" title="Web Flux"></a>Web Flux</h2><p>Spring 5引入的<strong>基于Netty而不是Servlet的高性能Web框架</strong>。但是使用方式并没有同传统的基于 Servlet 的 Spring MVC 有什么大的不同。</p>
<h2 id="Reactive-Streams、Reactor-和-Web-Flux"><a href="#Reactive-Streams、Reactor-和-Web-Flux" class="headerlink" title="Reactive Streams、Reactor 和 Web Flux"></a>Reactive Streams、Reactor 和 Web Flux</h2><p><strong>Reactive Streams 是规范，Reactor 实现了 Reactive Streams。Web Flux 以 Reactor 为基础，实现 Web 领域的反应式编程框架。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/16/Springboot%20%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/16/Springboot%20%E5%AE%9E%E6%88%98/" itemprop="url">Springboot 实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-16T11:19:38+01:00">
                2020-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Springboot-实战"><a href="#Springboot-实战" class="headerlink" title="Springboot 实战"></a>Springboot 实战</h1><h2 id="Spring-风云再起"><a href="#Spring-风云再起" class="headerlink" title="Spring 风云再起"></a>Spring 风云再起</h2><h3 id="Spring-Boot-精要"><a href="#Spring-Boot-精要" class="headerlink" title="Spring Boot 精要"></a>Spring Boot 精要</h3><ul>
<li><p><strong>自动配置</strong></p>
</li>
<li><p><strong>起步依赖</strong>：告诉Spring Boot需要什么功能，他就能引入需要的库。应用是个Web应用程序，加入Web起步依赖。 与之类似，如果应用程序要用到JPA持久化，那么就可以加入jpa起步依赖。如果需要安全功能， 那就加入security起步依赖。简而言之，你不再需要考虑支持某种功能要用什么库了，引入相关起 步依赖就行。它会根据依赖 传递把其他所需依赖引入项目里。</p>
</li>
<li><p><strong>命令行界面</strong>：无需传统项目构建。CLI能检测到你使用了哪些类，它知道要向Classpath中添加哪些起步依赖才</p>
<p>能让它运转起来。一旦那些依赖出现在Classpath中，一系列自动配置就会接踵而来，确保启用 DispatcherServlet和Spring MVC，这样控制器就能响应HTTP请求了。</p>
</li>
<li><p><strong>Actuator</strong>:可以深入运行中的Spring Boot应用程序。提供在运行时检视应用程序内部情况的能力</p>
</li>
</ul>
<h3 id="Spring-Boot不是什么"><a href="#Spring-Boot不是什么" class="headerlink" title="Spring Boot不是什么"></a>Spring Boot不是什么</h3><ul>
<li><strong>不是应用服务器</strong>。Spring Boot 在应用程序里嵌入了一个Servlet容器(Tomcat、Jetty或Undertow)，以此实现这一功能。但这是 内嵌的Servlet容器提供的功能，不是Spring Boot实现的。</li>
<li><strong>没有实现类似JPA，JMS之类的企业级Java规范</strong>。它的确支持不少企业级Java规范，但是要在Spring里自动配置支持那些特 性的Bean。例如，Spring Boot没有实现JPA，不过它自动配置了某个JPA实现(比如Hibernate)的 Bean，以此支持JPA。</li>
<li><strong>没有代码生成</strong>。利用Spring 4的条件化配置特性，和Maven, Gradle提供的传递依赖解析，来实现自动配置</li>
</ul>
<h2 id="开发第一个应用程序"><a href="#开发第一个应用程序" class="headerlink" title="开发第一个应用程序"></a>开发第一个应用程序</h2><h3 id="使用起步依赖"><a href="#使用起步依赖" class="headerlink" title="使用起步依赖"></a>使用起步依赖</h3><h4 id="指定基于功能的依赖"><a href="#指定基于功能的依赖" class="headerlink" title="指定基于功能的依赖"></a>指定基于功能的依赖</h4><p>起步依赖本质上是一个Maven项 目对象模型(Project Object Model，POM)，定义了对其他库的传递依赖。</p>
<p>不需要指定版本号，起步依赖本身的版本是由正在使用的Spring Boot的版本来决定 的，而起步依赖则会决定它们引入的传递依赖的版本。</p>
<h4 id="覆盖起步依赖引入的传递依赖"><a href="#覆盖起步依赖引入的传递依赖" class="headerlink" title="覆盖起步依赖引入的传递依赖"></a>覆盖起步依赖引入的传递依赖</h4><p>可以exclude某些依赖，也可以覆盖版本</p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/03/Spring%20Cloud%E5%92%8CDocker%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/03/Spring%20Cloud%E5%92%8CDocker%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/" itemprop="url">Spring Cloud和Docker微服务架构实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-03T21:21:38+01:00">
                2020-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-Cloud和Docker微服务架构实战"><a href="#Spring-Cloud和Docker微服务架构实战" class="headerlink" title="Spring Cloud和Docker微服务架构实战"></a>Spring Cloud和Docker微服务架构实战</h1><h2 id="微服务架构概述"><a href="#微服务架构概述" class="headerlink" title="微服务架构概述"></a>微服务架构概述</h2><h3 id="单体应用的问题"><a href="#单体应用的问题" class="headerlink" title="单体应用的问题"></a>单体应用的问题</h3><ul>
<li>复杂性高</li>
<li>技术债务：随着需求变更和人员更迭，会逐渐形成应用程序的技术债务</li>
<li>部署频率低：随着代码增多，构建和部署的时间也会增加</li>
<li>可靠性差</li>
<li>扩展能力受限</li>
<li>阻碍技术创新：每个成员都必须使用相同的语言和框架</li>
</ul>
<h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p><strong>将一个单一应用程序开发为一组小型服务</strong>。每个服务运行在自己的进程，服务间通信采用轻量级通信机制。微服务应具备以下特性：</p>
<ul>
<li>每个微服务独立运行在自己的进程</li>
<li>一系列微服务共同构建起整个系统</li>
<li>每个服务为独立的业务开发</li>
<li>微服务之间通过轻量级通信机制通信，如RESTful API</li>
<li>可以使用不同语言和技术</li>
<li>全自动部署</li>
</ul>
<h3 id="微服务架构的优点和挑战"><a href="#微服务架构的优点和挑战" class="headerlink" title="微服务架构的优点和挑战"></a>微服务架构的优点和挑战</h3><p>优点：</p>
<ul>
<li><strong>易于开发和维护</strong>：每个微服务业务清晰，代码量少</li>
<li>单个微服务<strong>启动快</strong></li>
<li><strong>局部修改</strong>容易部署</li>
<li><strong>技术栈</strong>不受限</li>
<li><strong>按需伸缩</strong></li>
</ul>
<p>挑战：</p>
<ul>
<li><strong>运维要求高</strong>：需要保证几十、几百个服务的正常运行和协作</li>
<li><strong>分布式的复杂性</strong>：系统容错、网络延迟、分布式事务</li>
<li><strong>接口调整成本高</strong>：如果修改某个微服务的API，所有使用该接口的微服务都要调整</li>
<li><strong>重复劳动</strong>：很多服务可能会使用相同的功能，从而代码重复</li>
</ul>
<h3 id="如何实现微服务架构"><a href="#如何实现微服务架构" class="headerlink" title="如何实现微服务架构"></a>如何实现微服务架构</h3><h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><p>从<strong>开发和运行平台两个维度</strong>考虑技术选型：</p>
<ul>
<li><p><strong>开发框架的选择</strong></p>
<p>Spring Cloud。开箱即用，文档丰富，社区活跃，完整的微服务架构解决方案</p>
<p>别的：Dubbo, Dropwizard, Armada</p>
</li>
<li><p><strong>运行平台</strong></p>
<p>微服务不绑定运行平台。PC Server, 阿里云，AWS等云计算平台都可以</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/02/Docker%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/Docker%20%E7%AC%94%E8%AE%B0/" itemprop="url">Docker 笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T21:07:43+01:00">
                2020-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker-笔记"><a href="#Docker-笔记" class="headerlink" title="Docker 笔记"></a>Docker 笔记</h1><p>[TOC]</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>操作系统=内核+用户空间。对于Linux, 由root文件系统为其提供用户空间支持。<strong>Docker镜像就相当于一个root文件系统。</strong></p>
<p>Docker镜像是一个特殊的<strong>文件系统</strong>， 除了提供容器运行时所需的程序、库、资源、配置等文件，还有一些配置参数（匿名卷、环境变量、用户等）。<strong>镜像不包含任何动态数据，内容在构建后也不会被改变</strong>。</p>
<p><strong>分层存储</strong></p>
<p>因为镜像包含完整的root文件系统，因此很庞大。Docker利用Union FS技术，将镜像设计为分层存储。所以镜像不像ISO是一个打包文件，而是由一组文件系统组成，<strong>由多层文件系统联合而成</strong>。</p>
<p>镜像构建时，会一层层构建。<strong>每一层构建完就不会再改变，后一层的任何改变只会发生在它那一层</strong>。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。因此，在构建镜像的时候，，每一层尽量只包含该层需要添加的东西，任何<strong>额外的东西应该在该层构建结束前清理掉</strong>。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><strong>镜像和容器，就像类和实例</strong>。镜像是静态的定义，容器是镜像运行时的实体。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程有自己的独立的命名空间。因此容器内进程是隔离与宿主系统的，像虚拟机一样。</p>
<p><strong>容器也是分层存储</strong>， 以镜像层为基础，在其上创建一个<strong>容器存储层</strong>，供容器运行时读写。<strong>容器存储层的生命周期和容器一样</strong>。</p>
<p>按照Docker最佳实践，<strong>容器不应该向其存储层内写入任何数据</strong>，容器存储层要保持无状态化。所有的文件写入操作，都应该使用<strong>[数据卷（Volume）</strong>、或者 绑定宿主目录，在这些位置的读写会<strong>跳过容器存储层</strong>，<strong>直接读写宿主（或网络存储）</strong>，其性能和稳定性更高。<strong>数据卷的生存周期独立于容器</strong>，容器消亡，数据卷不会消亡，因此容器删除或重新运行后，数据不会丢失。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Docker Registry是一个集中的存储、分发镜像的服务。一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<h2 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h2><ul>
<li><strong>列出镜像</strong> <code>docker image ls</code></li>
<li><strong>镜像体积</strong> <code>docker system df</code></li>
<li><strong>虚悬镜像dangling image</strong>：新旧镜像同名，旧镜像名称被取消，从而仓库名、标签名都为none,称为虚悬镜像。虚悬镜像一般都失去了价值，可以随意删除</li>
<li><strong>中间层镜像</strong>：用来加速镜像构建、重复利用资源。<code>docker image ls</code>只会列出顶层镜像，中间层镜像需要加-a: docker image ls -a</li>
<li><strong>列出部分镜像</strong>：<ul>
<li>根据仓库名列出镜像：<code>docker image ls ubuntu</code></li>
<li>指定仓库名和标签：<code>docker image ls ubuntu:18.04</code></li>
<li>过滤器：如在mongo:3.2之后建立的镜像：<code>docker image ls -f since=mongo:3.2</code></li>
</ul>
</li>
<li><strong>以特定格式显示</strong>：<ul>
<li><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作. <code>docker image ls -q</code>产生Image ID列表</li>
</ul>
</li>
</ul>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><ul>
<li><p><strong>删除本地镜像</strong> ：<code>docker image rm</code></p>
<ul>
<li>用ID、镜像名（仓库名和标签）、摘要删除镜像. <code>docker image ls --digests</code>列出摘要</li>
</ul>
</li>
<li><p><strong>Untagged和Deleted</strong>: </p>
<ul>
<li><strong>镜像的唯一标识是ID和摘要</strong>。一个镜像可以有多个标签。而使用非–digests删除镜像，实际上是在删除某个标签的镜像。因此需要先把该标签取消掉。如果还有别的标签指向这个镜像，就不会delete。因此不是所有的<code>docker image rm</code>都会删除镜像，有可能只是取消了标签。</li>
<li>当镜像所有标签都被取消，该镜像就失去了存在的意义，会被删除。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。如果有别的镜像依赖当前镜像的某一层，也不会删除。这也是为什么没有别的标签指向这个镜像，但是它还是存在的原因。</li>
<li>除了镜像依赖会阻止删除，容器依赖也会阻止删除。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。容器=镜像+容器存储层</li>
</ul>
</li>
<li><p><strong>配合docker image ls -q 和 shell</strong></p>
<ul>
<li>删除所有仓库名为redis的镜像：<code>docker image rm $(docker image ls -q redis)</code></li>
<li>删除所有在mongo:3.2之前的镜像：<code>docker image rm $(docker image ls -q -f before=mongo:3.2)</code></li>
</ul>
</li>
</ul>
<h2 id="利用commit理解镜像构成"><a href="#利用commit理解镜像构成" class="headerlink" title="利用commit理解镜像构成"></a>利用commit理解镜像构成</h2><p>利用终端修改容器的文件，即修改了容器的存储层。如果不使用卷的话，任何文件修改都会被记录在容器存储层。而Docker提供了一个docker commit命令，可以将容器的存储层保存成镜像。即，<strong>在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像</strong>。之后再运行这个新镜像，就会有原来容器最后的文件变化。</p>
<p><code>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>例子：<code>$ docker commit \
    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \
    --message &quot;修改了默认网页&quot; \
    webserver \
    nginx:v2</code></p>
<p>然后运行这个镜像：</p>
<p><code>docker run --name web2 -d -p 81:80 nginx:v2</code> 把本机的81端口映射到80端口</p>
<h4 id="慎用docker-commit"><a href="#慎用docker-commit" class="headerlink" title="慎用docker commit"></a>慎用docker commit</h4><p>实际中不用docker commit 生成镜像。原因：</p>
<ol>
<li><p>除了真正修改的文件，还有很多文件被改动或添加了。导致<strong>镜像臃肿</strong></p>
</li>
<li><p><strong>黑箱镜像</strong>。没人知道执行过什么命令、怎么生成的镜像</p>
</li>
</ol>
<h2 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h2><p>镜像的定制，就是定制每一层所添加的配置、文件。把每一层的命令都写入脚本，就解决了无法重复、镜像构建透明性的问题。这个脚本就是Dockerfile。</p>
<p>Dockerfile里每一个指令都会构建一层，因此每一条指令就是描述该层如何构建。</p>
<h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><p>一个特殊的镜像：scratch。这个镜像是虚拟概念，并不实际存在。表示一个空白镜像。以scratch为基础，则所写的指令将作为镜像第一层存在。</p>
<h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><p>执行命令行命令。</p>
<ul>
<li><strong>shell格式</strong>： RUN &lt;命令&gt; 如<code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></li>
<li><strong>exec 格式</strong>：<code>RUN [&quot;可执行文件&quot;，&quot;参数1&quot;,&quot;参数2&quot;]</code></li>
</ul>
<p>每一个RUN，都会新建立一层，然后commit这一层的修改，构成新的镜像。但是要注意删掉多余的东西（如安装包），否则镜像非常臃肿，非常多层，会增加部署的时间，也容易出错。<strong>每一层构建后一定要清理掉无关文件</strong></p>
<p>Union FS是有最大层数限制的。比如AUFS，不得超过127层。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p><code>docker build -t 最终镜像名称 &lt;上下文路径&gt;</code> 命令中.表示当前目录</p>
<h3 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h3><p>Docker是CS设计。Docker运行时分为Docker引擎和客户端工具。Docker引擎提供一组REST API，像docker命令行这样的客户端工具，则通过这组API与Docker引擎交互。</p>
<p><strong>镜像不是在本地，而是在服务端，即Docker引擎中构建的</strong>。Docker build得知构建镜像上下文路径后，将这个路径下所有内容打包，上传给Docker引擎，这样Docker引擎就可以获得构建镜像需要的一切文件，从而构建镜像。<strong>Dockerfile中的.代表上下文目录。</strong></p>
<h3 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h3><p><code>COPY &lt;源路径&gt; &lt;目标路径&gt;</code> 将从<strong>构建上下文目录中</strong> <code>&lt;源路径&gt;</code> 的文件/目录复制到<strong>新的一层的镜像内</strong>的 <code>&lt;目标路径&gt;</code> 位置。</p>
<h3 id="ADD更高级的复制文件"><a href="#ADD更高级的复制文件" class="headerlink" title="ADD更高级的复制文件"></a>ADD更高级的复制文件</h3><p>ADD在COPY基础上增加了一些功能。源路径可以是URL，可以是压缩文件（会自动解压）。但是<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p>
<h3 id="CMD容器启动命令"><a href="#CMD容器启动命令" class="headerlink" title="CMD容器启动命令"></a>CMD容器启动命令</h3><p>指定容器启动程序和参数。</p>
<p>和RUN相似，也是两种格式：</p>
<ul>
<li><strong>shell 格式</strong> CMD &lt;命令&gt;</li>
<li><strong>exec格式</strong> CMD [可执行文件 参数…]</li>
</ul>
<p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code>指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p><code>CMD service nginx start</code> 容器执行后会立即退出。主进程是sh，当service nginx start命令结束后，sh就结束了，容器也会退出。容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<h3 id="ENTRYPOINT入口点"><a href="#ENTRYPOINT入口点" class="headerlink" title="ENTRYPOINT入口点"></a>ENTRYPOINT入口点</h3><p>目的和CMD一样，也是指定容器启动程序和参数。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令：</p>
<p><code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></p>
<h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>可以很方便的加参数</p>
<h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>运行前的准备工作和容器CMD无关，可以把这些写一个脚本，放入ENTRYPOINT执行</p>
<h3 id="ENV设置环境变量"><a href="#ENV设置环境变量" class="headerlink" title="ENV设置环境变量"></a>ENV设置环境变量</h3><p>无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<h3 id="ARG构建参数"><a href="#ARG构建参数" class="headerlink" title="ARG构建参数"></a>ARG构建参数</h3><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p>
<h3 id="VOLUME定义匿名卷"><a href="#VOLUME定义匿名卷" class="headerlink" title="VOLUME定义匿名卷"></a>VOLUME定义匿名卷</h3><p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></p>
<p>容器运行时应该尽量不写容器存储层，对于数据库类需要保存动态数据的，应该保存在卷volume中。</p>
<p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，避免向容器存储层写入大量数据</p>
<h3 id="EXPOSE暴露端口"><a href="#EXPOSE暴露端口" class="headerlink" title="EXPOSE暴露端口"></a>EXPOSE暴露端口</h3><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<p>声明运行时容器提供服务的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR指定工作目录"><a href="#WORKDIR指定工作目录" class="headerlink" title="WORKDIR指定工作目录"></a>WORKDIR指定工作目录</h3><p><code>WORKDIR &lt;工作目录路径&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure>

<p>会找不到world.txt。因为前后两行RUN的执行环境根本不同，是两个不同的容器。要了解Dockerfile的分层构建存储</p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一行RUN没有文件变更，只是内存变化。第二层的容器不会继承第一层构建过程中的内存变化</p>
<p>因此如果需要改变以后各层的工作目录，使用WORKDIR指令</p>
<h3 id="USER指定当前用户"><a href="#USER指定当前用户" class="headerlink" title="USER指定当前用户"></a>USER指定当前用户</h3><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p>和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层.<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<h3 id="HEALTHCHECK健康检查"><a href="#HEALTHCHECK健康检查" class="headerlink" title="HEALTHCHECK健康检查"></a>HEALTHCHECK健康检查</h3><p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code></p>
<p>健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<h3 id="ONBUILD方便他人以自己为基础镜像来构建镜像"><a href="#ONBUILD方便他人以自己为基础镜像来构建镜像" class="headerlink" title="ONBUILD方便他人以自己为基础镜像来构建镜像"></a>ONBUILD方便他人以自己为基础镜像来构建镜像</h3><p><code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的其它指令，比如 <code>RUN</code>, <code>COPY</code> 等在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<h3 id="LABEL给镜像添加元数据"><a href="#LABEL给镜像添加元数据" class="headerlink" title="LABEL给镜像添加元数据"></a>LABEL给镜像添加元数据</h3><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。可以用来申明镜像的作者、文档地址等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h3><p>旧做法：</p>
<ul>
<li>全部放入一个Dockerfile，包括项目及其依赖库的编译、测试、打包<ul>
<li>镜像层次多，体积大，部署时间长</li>
<li>源代码存在泄漏风险</li>
</ul>
</li>
<li>分散到多个Dockerfile，事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，需要编写两个 <code>Dockerfile</code> 和一些编译脚本<ul>
<li>部署复杂</li>
</ul>
</li>
</ul>
<p>多阶段构建：只需要编写一个Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine as builder</span><br><span class="line"></span><br><span class="line">RUN apk --no-cache add git</span><br><span class="line"></span><br><span class="line">WORKDIR &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;</span><br><span class="line"></span><br><span class="line">RUN go get -d -v github.com&#x2F;go-sql-driver&#x2F;mysql</span><br><span class="line"></span><br><span class="line">COPY app.go .</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest as prod</span><br><span class="line"></span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR &#x2F;root&#x2F;</span><br><span class="line"></span><br><span class="line">COPY --from&#x3D;0 &#x2F;go&#x2F;src&#x2F;github.com&#x2F;go&#x2F;helloworld&#x2F;app .</span><br><span class="line"></span><br><span class="line">CMD [&quot;.&#x2F;app&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>只构建某一阶段的镜像，</p>
<p>用as命名：<code>FROM golang:1.9-alpine as builder</code></p>
<p>构建时加–target=builder参数：<code>$ docker build --target builder -t username/imagename:tag .</code></p>
</li>
<li><p>构建时从其他镜像复制文件</p>
<p>从上一阶段的镜像中复制文件：<code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code></p>
<p>复制任意镜像中的文件：<code>$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></p>
</li>
</ul>
<h2 id="构建多种系统架构支持的Docker镜像"><a href="#构建多种系统架构支持的Docker镜像" class="headerlink" title="构建多种系统架构支持的Docker镜像"></a>构建多种系统架构支持的Docker镜像</h2><p><strong>使用镜像创建一个容器，该镜像必须与 Docker 宿主机系统架构一致</strong>，例如 <code>Linux x86_64</code> 架构的系统中只能使用 <code>Linux x86_64</code> 的镜像创建容器。</p>
<p>Windows、macOS 除外，其使用了 <a href="https://docs.docker.com/docker-for-mac/multi-arch/" target="_blank" rel="noopener">binfmt_misc</a> 提供了多种架构支持，在 Windows、macOS 系统上 (x86_64) 可以运行 arm 等其他架构的镜像。</p>
<p><strong>使用manifest列表，让Docker引擎根据系统架构自动拉取对应镜像</strong></p>
<p>当用户获取一个镜像时，Docker 引擎会首先查找该镜像是否有 <code>manifest</code> 列表，如果有的话 Docker 引擎会按照 Docker 运行环境（系统及架构）查找出对应镜像（例如 <code>golang:alpine</code>）。如果没有的话会直接获取镜像.</p>
<p><code>manifest</code> 列表中包含了不同系统架构所对应的镜像 <code>digest</code> 值，这样 Docker 就可以在不同的架构中使用相同的 <code>manifest</code> (例如 <code>golang:alpine</code>) 获取对应的镜像</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Docker 镜像是怎么实现增量的修改和维护的？</p>
<p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p><code>UnionFS</code>（联合文件系统）: Union文件系统（UnionFS）是一种<code>分层</code>、<code>轻量级</code>并且<code>高性能</code>的<code>文件系统</code>，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>通常 Union FS 有两个用途, </p>
<ul>
<li>可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下</li>
<li>另一个是<strong>将一个只读的分支和一个可写的分支联合在一起</strong>，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</li>
</ul>
<h3 id="unionFS："><a href="#unionFS：" class="headerlink" title="unionFS："></a><strong>unionFS</strong>：</h3><p>顾名思义，unionFS可以把文件系统上多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。</p>
<p>要理解unionFS，我们首先要认识<strong>bootfs</strong>和rootfs。</p>
<ol>
<li><strong>boot file system （bootfs）</strong>：包含操作系统boot loader 和 kernel。用户不会修改这个文件系统。</li>
</ol>
<p>一旦启动完成后，整个Linux内核加载进内存，之后bootfs会被卸载掉，从而释放出内存。</p>
<p>同样内核版本的不同的 Linux 发行版，其bootfs都是一致的。</p>
<ol start="2">
<li><strong>root file system （rootfs）</strong>：包含典型的目录结构，包括 /dev, /proc, /bin, /etc, /lib, /usr, and /tmp</li>
</ol>
<p>Linux 系统在启动时，roofs 首先会被挂载为只读模式，然后在启动完成后被修改为读写模式，随后它们就可以被修改了。</p>
<p><strong>实际例子：</strong></p>
<ol>
<li>新建两个文件夹abap和java，分别创建两个空文件：</li>
</ol>
<p>![](/Users/yesun/Documents/screenshots/笔记/Docker/截屏2020-11-06 10.37.19.png)</p>
<ol start="2">
<li>新建一个mnt文件夹，用mount命令把abap和java文件夹merge到mnt文件夹下，文件系统类型为aufs：</li>
</ol>
<p>![](/Users/yesun/Documents/screenshots/笔记/Docker/截屏2020-11-06 10.39.00.png)</p>
<p>​    此时mnt文件夹里有之前4个文件</p>
<ol start="3">
<li>现在更新java/spring, mnt里的spring 也会被自动更新。但是更新mnt里的spring, java/spring不会更新。因为此时写的不是原文件，是<strong>原文件的拷贝（写时拷贝），这是可写的分支。原文件是只读的分支（对容器来说）</strong></li>
</ol>
<p>这就是Docker容器分层实现的技术基础。分层设计的优点是资源共享，每个容器不用各自保留一份debian拷贝，借助Linux的unionFS，宿主机只需要在磁盘上保存一份base镜像，内存中也只需要加载一份，就能被所有基于这个镜像的容器共享。</p>
<p>而且根据容器镜像的<strong>写时拷贝技术</strong>，某个容器对基础镜像的修改会被限制在单个容器内。</p>
<p>比如如下镜像：</p>
<img src="/Users/yesun/Documents/screenshots/笔记/Docker/截屏2020-11-06 10.44.28.png" style="zoom:50%;" />

<p>当用docker run启动一个该镜像的容器时，实际上在镜像的顶部添加了一个新的可写层。这个可写层也叫容器层。</p>
<img src="/Users/yesun/Documents/screenshots/笔记/Docker/截屏2020-11-06 10.45.21.png" style="zoom:50%;" />

<p>容器启动后，其内的应用所有对容器的改动，文件的增删改操作都只会发生在容器层中，对容器层下面的所有只读镜像层没有影响。</p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p><code>docker run -t -i ubuntu:18.04 /bin/bash</code> 创建一个终端</p>
<p>使用docker run创建容器时，Docker的后台操作包括：</p>
<ul>
<li>检查本地是否有指定<strong>镜像</strong>，没有就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面<strong>挂载一层可读写层</strong></li>
<li>从宿主机配置的<strong>网桥接口</strong>中<strong>桥接一个虚拟接口</strong>到容器中</li>
<li>从地址池<strong>分配一个IP地址</strong>给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p><code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。</p>
<h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。通过添加 <code>-d</code> 参数来实现</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id</p>
<p>要<strong>获取容器的输出信息</strong>，可以通过 <code>docker container logs</code> 命令。</p>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p><code>docker container stop</code> 来终止一个运行中的容器。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，进入容器。<strong>推荐使用exec</strong></p>
<h3 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h3><p>如果从attach启动的 stdin 中 exit，会导致容器的停止。</p>
<h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h3><p>常跟<code>-it</code>参数。只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<p>如果从exec启动的 stdin 中 exit，不会导致容器的停止。</p>
<h2 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p><code>docker export</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker export 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>

<p>导出容器快照到本地文件。</p>
<h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>使用 <code>docker import</code> 从容器快照文件中再导入为镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - test&#x2F;ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test&#x2F;ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure>

<p><em>用户既可以使用</em> <em><code>docker load</code></em> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <em><code>docker import</code></em> <em>来导入一个容器快照到本地镜像库</em></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>docker container rm</code> 来删除一个处于终止状态的容器</p>
<p><code>docker container prune</code>清理掉所有处于终止状态的容器。</p>
<h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><p>库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上<strong>注册服务器是管理仓库的具体服务器</strong>，<strong>每个服务器上可以有多个仓库</strong>，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <strong><code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</strong></p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li><strong>数据卷（Volumes）</strong></li>
<li><strong>挂载主机目录 (Bind mounts)</strong></li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p><code>数据卷</code> 是一个<strong>可供一个或多个容器使用</strong>的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在<strong>容器之间共享</strong>和重用</li>
<li>对 <code>数据卷</code> 的<strong>修改会立马生效</strong></li>
<li>对 <code>数据卷</code> 的更新，<strong>不会影响镜像</strong></li>
<li><code>数据卷</code> 默认会<strong>一直存在</strong>，即使容器被删除</li>
</ul>
<h4 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h4><p><code>docker volume create my-vol</code></p>
<p><code>docker volume inspect my-vol</code>查看指定数据卷的信息</p>
<h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">    --mount source&#x3D;my-vol,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<h4 id="查看数据卷具体信息"><a href="#查看数据卷具体信息" class="headerlink" title="查看数据卷具体信息"></a>查看数据卷具体信息</h4><p><code>docker inspect web</code></p>
<h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p><code>docker volume rm my-vol</code></p>
<p>数据卷的生命周期独立于容器。Docker不会在容器被删除后自动删除数据卷，也没有垃圾回收机制。</p>
<p>如果要在删除容器的同时删除数据卷，删除容器时使用<code>docker rm -v</code></p>
<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v &#x2F;src&#x2F;webapp:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">    --mount type&#x3D;bind,source&#x3D;&#x2F;src&#x2F;webapp,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。</p>
<p>本地路径必须是绝对路径</p>
<h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">   # -v $HOME&#x2F;.bash_history:&#x2F;root&#x2F;.bash_history \</span><br><span class="line">   --mount type&#x3D;bind,source&#x3D;$HOME&#x2F;.bash_history,target&#x3D;&#x2F;root&#x2F;.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:&#x2F;# history</span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure>

<p>这样就可以记录在容器输入过的命令了。</p>
<h2 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h2><p>Docker允许通过<strong>外部访问容器</strong>或<strong>容器互联</strong>的方式提供网络服务。</p>
<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>run使用<code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口</p>
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort 映射指定地址的指定端口| ip::containerPort 映射指定地址的任意端口 | hostPort:containerPort映射所有接口地址</code>。</p>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>不要使用–link参数互联容器，建议<strong>将容器加入自定义的Docker网络</strong>里链接多个容器</p>
<h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p><code>docker network create -d bridge my-net</code></p>
<h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/GIT%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/GIT%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" itemprop="url">GIT实用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-21T04:25:48+02:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="GIT实用技巧"><a href="#GIT实用技巧" class="headerlink" title="GIT实用技巧"></a>GIT实用技巧</h1><h2 id="用git-rebase合并commit"><a href="#用git-rebase合并commit" class="headerlink" title="用git rebase合并commit"></a>用git rebase合并commit</h2><ul>
<li><p>Git rebase -i –root</p>
</li>
<li><p>把要合并的commit前面的pick改成s</p>
</li>
<li><p>输入合并的commit msg</p>
</li>
<li><p>Push</p>
</li>
</ul>
<h2 id="git-reflog恢复commit节点或者分支到rebase以前"><a href="#git-reflog恢复commit节点或者分支到rebase以前" class="headerlink" title="git reflog恢复commit节点或者分支到rebase以前"></a>git reflog恢复commit节点或者分支到rebase以前</h2><ul>
<li><p>Git reflog找到合并前的状态的哈希值</p>
</li>
<li><p>再get reset –hard 哈希值</p>
</li>
</ul>
<p>ref是可变指针，指向一个个commit对象，<strong>reflog就是ref的log</strong>,可以理解成<strong>版本控制的版本控制</strong></p>
<h2 id="获得干净的工作空间同时保留暂时的变更"><a href="#获得干净的工作空间同时保留暂时的变更" class="headerlink" title="获得干净的工作空间同时保留暂时的变更"></a>获得干净的工作空间同时保留暂时的变更</h2><p>git stash push -u</p>
<p>git stash pop来恢复刚才的暂存变更</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/KM%E7%AC%94%E8%AE%B0%20--%20%E6%B5%B7%E9%87%8F%E4%B9%8B%E9%81%93%E7%B3%BB%E5%88%97%E4%B9%8B%E6%9C%89%E6%8D%9F%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/KM%E7%AC%94%E8%AE%B0%20--%20%E6%B5%B7%E9%87%8F%E4%B9%8B%E9%81%93%E7%B3%BB%E5%88%97%E4%B9%8B%E6%9C%89%E6%8D%9F%E6%9C%8D%E5%8A%A1/" itemprop="url">KM笔记 -- 海量之道系列之有损服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-21T04:03:23+02:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="KM笔记-–-海量之道系列之有损服务"><a href="#KM笔记-–-海量之道系列之有损服务" class="headerlink" title="KM笔记 – 海量之道系列之有损服务"></a>KM笔记 – 海量之道系列之有损服务</h1><p>海量之道两大技术价值观：<strong>有损服务</strong> 和 <strong>动态运营</strong></p>
<p>有损服务<strong>核心思想</strong>：</p>
<ul>
<li><strong>放弃绝对一致，追求速度极致</strong></li>
<li><strong>万有一失，用户重试</strong></li>
<li><strong>伸缩调度，降级服务</strong></li>
</ul>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition Tolerance</li>
</ul>
<p>对分布式系统而言，分区容错性是基本要求，可用性和一致性必须有取舍。</p>
<p>金融行业选择了强一致性，因此投入了巨大的IT成本。而对于很多web应用，并不需要强一致性，可以通过<strong>牺牲实时强一致性，换取高可用性</strong>。</p>
<h2 id="CAP演化而来的BASE"><a href="#CAP演化而来的BASE" class="headerlink" title="CAP演化而来的BASE"></a>CAP演化而来的BASE</h2><p>核心思想：即便不能达到强一致性，可以采用适当方式<strong>达到最终一致性</strong>。</p>
<ul>
<li><strong>Basically Available</strong>: 基本可用</li>
<li><strong>Soft-state</strong>: 软状态/柔性事务。即状态可以暂时不同步</li>
<li><strong>Eventual consistency</strong>: 最终一致性</li>
</ul>
<p>BASE是反ACID的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/%E5%9B%BE%E8%A7%A3http%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%9B%BE%E8%A7%A3http%E7%AC%94%E8%AE%B0/" itemprop="url">图解http笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-21T04:03:23+02:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图解HTTP笔记"><a href="#图解HTTP笔记" class="headerlink" title="图解HTTP笔记"></a>图解HTTP笔记</h1><p>[TOC]</p>
<h2 id="第2章-简单的HTTP协议"><a href="#第2章-简单的HTTP协议" class="headerlink" title="第2章 简单的HTTP协议"></a>第2章 简单的HTTP协议</h2><h3 id="通过响应和请求的交换达成通信"><a href="#通过响应和请求的交换达成通信" class="headerlink" title="通过响应和请求的交换达成通信"></a>通过响应和请求的交换达成通信</h3><p>请求报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--方法, URI, 协议版本--&gt;</span><br><span class="line">GET &#x2F;index.htm HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">&lt;!--请求首部字段--&gt;</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Conted-Length: 16</span><br><span class="line"></span><br><span class="line">&lt;!--内容实体--&gt;</span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br></pre></td></tr></table></figure>

<ul>
<li>GET: 请求访问服务器的类型，称为方法</li>
<li>/index.htm: 请求访问的资源对象</li>
<li>HTTP/1.1: 客户端使用的HTTP协议版本</li>
</ul>
<p>请求报文构成：<strong>请求方法、请求URI、协议版本、可选的请求首部字段、内容实体</strong></p>
<p>响应报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--协议版本，状态码，状态码的原因短语--&gt;</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line">&lt;!--响应首部字段--&gt;</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length:362</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">&lt;!--主体--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="不保存状态协议"><a href="#不保存状态协议" class="headerlink" title="不保存状态协议"></a>不保存状态协议</h3><p><strong>协议对发送过的请求或响应都不做持久化处理</strong>。 为了更快地处理大量事务，确保协议的可伸缩性</p>
<h3 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a>请求URI定位资源</h3><p>客户端发送请求时，URI需要将请求报文中的请求URI包含在内。</p>
<p><strong>指定URI的方式</strong>：</p>
<ul>
<li><p>URI完整: <code>GET http://hackr.jp/index.htm HTTP/1.1</code></p>
</li>
<li><p>URI+Host: </p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: hackr.jp</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>若对服务器本身发起请求，用*代替请求URI</p>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><h4 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h4><p>用来请求已被URI识别的资源。请求文本，则原样返回。请求CGI程序（通用网管接口），返回执行后的输出结果。</p>
<p>请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Hotst</span>: www.hackr.jp</span><br><span class="line"><span class="attribute">If-Modified-Since</span>: Thu. 12 Jul 2012 07:30:00 GMT</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仅返回2012.7.12，7:30后更新过的资源。若未更新，返回304 Not Modified</span><br></pre></td></tr></table></figure>



<p>响应：</p>
<h4 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h4><p>请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br><span class="line">Content-Length:1560 (1560字节数据)</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回submit.cgi接受数据的处理结果</span><br></pre></td></tr></table></figure>

<h4 id="PUT-传输文件"><a href="#PUT-传输文件" class="headerlink" title="PUT: 传输文件"></a>PUT: 传输文件</h4><p>将请求主体中的文件内容保存到请求URI。</p>
<p>但是由于PUT方法没有验证机制，任何人都能上传文件，有安全性问题，因此一般不使用</p>
<p>请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/example.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line">Content-Length:1560 (1560字节数据)</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回204 No Content（如果该html已经在服务器上）</span><br></pre></td></tr></table></figure>

<h4 id="DELETE-删除文件"><a href="#DELETE-删除文件" class="headerlink" title="DELETE: 删除文件"></a>DELETE: 删除文件</h4><p>同PUT一样，自身没有验证机制，一般不用。</p>
<p>请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/example.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回204 No Content（如果该html已经被删除）</span><br></pre></td></tr></table></figure>

<h4 id="HEAD：获得响应报文首部"><a href="#HEAD：获得响应报文首部" class="headerlink" title="HEAD：获得响应报文首部"></a>HEAD：获得响应报文首部</h4><p>用于确认URI有效性和资源更新的时间等。</p>
<p>请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回index.html有关的响应首部</span><br></pre></td></tr></table></figure>

<h4 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h4><p>查询请求URI指定资源支持的方法</p>
<p>请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONES</span> <span class="string">/example.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Allow</span>: GET,POST,HEAD,OPTIONS</span><br></pre></td></tr></table></figure>

<h4 id="TRACE-追踪路径"><a href="#TRACE-追踪路径" class="headerlink" title="TRACE: 追踪路径"></a>TRACE: 追踪路径</h4><p>将服务器端的请求通信环回给客户端。可以查询请求是怎样被加工的。</p>
<p>发送请求时，在Max-Forwards首部字段填入数值，每经过一个服务端，就减一，为0时返回200OK的响应。</p>
<p>容易引发XST攻击（跨站追踪），很少用</p>
<h4 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h4><p>要求与代理服务器建立隧道，用隧道协议进行TCP通信。使用<strong>SSL（安全套接层）和TLS协议（传输层安全协议）把通信内容加密</strong>后经隧道传输。</p>
<p>请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">proxy.hackr.jp:8080</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK (之后进入网络隧道)</span><br></pre></td></tr></table></figure>

<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>只有任意一段没有提出断开连接，则保持TCP连接状态。</p>
<p>HTTP/1.1中所有连接都默认是持久连接</p>
<h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>发送完一个请求后，不用等待响应，就可以发送下一个请求。</p>
<h3 id="使用Cookie进行状态管理"><a href="#使用Cookie进行状态管理" class="headerlink" title="使用Cookie进行状态管理"></a>使用Cookie进行状态管理</h3><p>Cookie会根据服务端发送的响应报文中Set-Cookie的首部字段信息，通知客户端保存Cookie，下次再发送请求时，自动在请求报文中加入Cookie值。</p>
<p>服务端发现客户端发送的Cookie后，会检查来自哪一个客户端，再对比服务器上的记录，得到状态信息。</p>
<p>请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/example.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: ...</span><br><span class="line"><span class="attribute">Server</span>: Apache</span><br><span class="line">&lt;Set-Cookie: sid=34141341143; path=/; expires=Wed, =&gt; 10-Oct-12 07:33:32 GMT&gt;</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain; charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>再次请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/example.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.hackr.jp</span><br><span class="line"><span class="attribute">Cookie</span>: sid=34141341143</span><br></pre></td></tr></table></figure>

<h2 id="第3章-HTTP报文内的HTTP信息"><a href="#第3章-HTTP报文内的HTTP信息" class="headerlink" title="第3章 HTTP报文内的HTTP信息"></a>第3章 HTTP报文内的HTTP信息</h2><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1809.22.57.png" style="zoom:50%;" />

<h3 id="请求报文和响应报文的结构"><a href="#请求报文和响应报文的结构" class="headerlink" title="请求报文和响应报文的结构"></a>请求报文和响应报文的结构</h3><img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1809.28.32.png" alt="截屏2020-06-1809.28.32" style="zoom:50%;" />

<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1809.31.27.png" alt="截屏2020-06-1809.31.27" style="zoom:50%;" />

<p>四种首部字段：</p>
<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
</ul>
<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP可以把数据原样传输，也可以通过编码提升传输速率。但是编码需要消耗更多的CPU资源。</p>
<h4 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h4><ul>
<li><p><strong>报文</strong></p>
<p>HTTP通信中的基本单位，8位组字节流组成。</p>
</li>
<li><p><strong>实体</strong></p>
<p>请求或响应的有效载荷数据。由<strong>实体首部和实体主体</strong>组成。</p>
</li>
</ul>
<p>报文主体用于传输实体主体。通常下两者相等。<strong>只有当编码传输时</strong>，实体主体的内容变化，<strong>才会和报文主体产生差异。</strong></p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明编码格式，并把实体信息压缩。客户端接受后再解码（解压缩）。</p>
<p>常用的内容编码：</p>
<ul>
<li>gzip</li>
<li>compress</li>
<li>deflate (zlib)</li>
<li>Identity (不编码)</li>
</ul>
<h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>分割数据，让浏览器能逐步显示页面。每一块都标记了大小。由客户端解码，恢复实体主体。</p>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>发送的一份报文主体内可含有多种类型实体。</p>
<ul>
<li><p>multipart/form-data</p>
<p>上传web表单文件时</p>
<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1809.55.16.png" alt="截屏2020-06-1809.55.16" style="zoom:50%;" />
</li>
<li><p>multipart/byteranges</p>
<p>响应报文包含多个范围内容时。</p>
</li>
</ul>
<p>每个部分类型中，都可以含有首部字段，而且可以嵌套使用。</p>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>需要一种<strong>可恢复的机制</strong>，可以从下载中断处恢复下载。</p>
<p>用<strong>Range首部字段</strong>指定资源的byte范围。</p>
<p>响应返回状态码<strong>206 Partial Content</strong>的响应报文。若无法响应范围请求，返回状态码200 OK和完整实体内容。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>访问相同URI页面时，显示浏览器语言对应的页面。</p>
<p>内容协商以响应资源的语言、字符集、编码方式作为判断标准。</p>
<p>3中内容协商：</p>
<ul>
<li><strong>服务器驱动协商</strong>：服务端以浏览器发送的信息作为判定依据，但不一定能筛选出最优内容</li>
<li><strong>客户端驱动协商</strong>：用户从可选列表中手动选择</li>
<li><strong>透明协商</strong>：以上两者结合体。</li>
</ul>
<h2 id="第4章-状态码"><a href="#第4章-状态码" class="headerlink" title="第4章 状态码"></a>第4章 状态码</h2><p>状态码类别：</p>
<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1810.07.52.png" alt="截屏2020-06-1810.07.52" style="zoom:50%;" />

<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>请求被正常处理了</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>请求处理成功，但没有资源可返回。</p>
<p>在只需要从客户端往服务器发送信息时使用。</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文由Content-Range指定范围的实体内容</p>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>表明浏览器需要执行某些特殊的处理来正确处理请求</p>
<h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p><strong>永久性重定向</strong>。表示请求的资源已经被分配了新的URI，以后应使用资源现在所在的URI。</p>
<p>若把URI保存为书签了，此时应该按照Location首部字段的提示URI重新保存。</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p><strong>临时性重定向</strong>。分配了新的URI，希望用户本次使用新的URI访问。</p>
<p>不会更新书签。</p>
<h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>表示资源有另一个URI，应使用GET方法重新定向获取。</p>
<p>和302 Found类似，但明确表示了<strong>应采用GET方法</strong>获取资源。</p>
<p><strong>301，302，303</strong>返回时，几乎所有的浏览器都会<strong>把POST改成GET</strong>，并删除请求报文内的主体，之后请求会再次发送。</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>和重定向无关。客户端发送带条件的请求时，服务端允许请求访问资源，但不满足条件。不返回响应主体。</p>
<h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p><strong>临时重定向</strong>。返回307时，不会从POST变成GET。</p>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>请求报文中包含语法错误。</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>表示请求需要有通过HTTP认证的认知信息或用户认证失败。</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>访问被拒绝。服务器端没有必要给出拒绝理由。可能是因为访问权限问题。</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>无法找到资源。也可以在拒绝请求且不想说明理由时使用</p>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>服务器端在执行请求时发生了错误</p>
<h4 id="503-Service-Unabailable"><a href="#503-Service-Unabailable" class="headerlink" title="503 Service Unabailable"></a>503 Service Unabailable</h4><p>服务器暂时超负载或停机维护，步伐处理请求</p>
<h2 id="第5章-与HTTP协作的Web服务器"><a href="#第5章-与HTTP协作的Web服务器" class="headerlink" title="第5章 与HTTP协作的Web服务器"></a>第5章 与HTTP协作的Web服务器</h2><h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>主机名=服务器名+域名</p>
<p>例子：<a href="http://www.sina.com.cn/" target="_blank" rel="noopener">http://www.sina.com.cn/</a></p>
<p>服务器名：www</p>
<p>域名：sina.com.cn</p>
<p>主机名：<a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p>
<p>虚拟主机可以寄存多个不同主机名和域名的Web网站</p>
<p><a href="http://www.tricorder.jp和www.hackr.jp部署在同一个服务器上，因此域名会解析为相同的IP地址，因此必须在Host首部内完整指定URI。" target="_blank" rel="noopener">www.tricorder.jp和www.hackr.jp部署在同一个服务器上，因此域名会解析为相同的IP地址，因此必须在Host首部内完整指定URI。</a></p>
<h3 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h3><ul>
<li><p><strong>代理</strong>：转发客户端请求，不改变URI。每次通过代理服务器转发时，会追加写入Via首部信息。</p>
<p>好处：利用缓存减少网络带宽流量，组织内部针对特定网站的访问控制</p>
<ul>
<li><strong>缓存代理</strong>：转发响应时，将资源缓存在代理服务器上。</li>
<li><strong>透明代理</strong>：不对报文加工的代理为透明代理，否则为非透明代理。</li>
</ul>
</li>
<li><p><strong>网关</strong>：网关可以<strong>把HTTP请求转化为其他协议</strong>通信。网关还可以提高安全性，可以加密和客户端的通信线路。</p>
</li>
<li><p><strong>隧道</strong>：建立一条使用SSL等加密手段进行通信的通信线路。确保客户端与服务器进行安全的通信。不解析HTTP请求。</p>
</li>
</ul>
<h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h3><p>利用代理服务器或本地缓存可以<strong>减少通信流量和通信时间</strong>。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>判断缓存是否失效，缓存服务器会再次从源服务器上获取新资源。</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h4><p>判断缓存是否失效，缓存服务器会再次从源服务器上获取新资源。</p>
<h2 id="第6章-HTTP首部"><a href="#第6章-HTTP首部" class="headerlink" title="第6章 HTTP首部"></a>第6章 HTTP首部</h2><h3 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h3><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.25.37.png" alt="截屏2020-06-1814.25.37" style="zoom:50%;" />

<h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.26.48.png" alt="截屏2020-06-1814.26.48" style="zoom:50%;" />

<h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>首部重复了怎么办：无统一规定。有的浏览器优先处理第一次出现的，有的优先处理最后出现的。</p>
<h4 id="4种首部字段类型"><a href="#4种首部字段类型" class="headerlink" title="4种首部字段类型"></a>4种首部字段类型</h4><ul>
<li><strong>通用首部字段</strong>：请求和响应都会用</li>
<li><strong>请求首部字段</strong>：客户端信息，响应内容相关优先级</li>
<li><strong>响应首部字段：</strong></li>
<li><strong>实体首部字段</strong>：资源更新时间等</li>
</ul>
<p>通用首部字段：</p>
<p>Cache-Control, Connection, Date, Via</p>
<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.41.00.png" alt="截屏2020-06-1814.41.00" style="zoom:50%;" />

<p>请求首部字段：</p>
<p>Accept, Expecte, From, Host, If-Match, If-Modified-Since</p>
<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.42.04.png" alt="截屏2020-06-1814.42.04" style="zoom:50%;" />

<p>响应首部字段：</p>
<p>Accept-Ranges, Age, Location, Server, Vary</p>
<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.44.05.png" alt="截屏2020-06-1814.44.05" style="zoom:50%;" />

<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.44.25.png" alt="截屏2020-06-1814.44.25" style="zoom:50%;" />

<p>实体首部字段：</p>
<p>Allow, Content-Encoding, Content-Language, Content-Length, Expires</p>
<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1814.44.47.png" alt="截屏2020-06-1814.44.47" style="zoom:50%;" />

<h4 id="非HTTP-1-1首部字段"><a href="#非HTTP-1-1首部字段" class="headerlink" title="非HTTP/1.1首部字段"></a>非HTTP/1.1首部字段</h4><p>Cookie, Set-Cookie, Content-Disposition等</p>
<h4 id="End-to-end-Hop-by-hop首部"><a href="#End-to-end-Hop-by-hop首部" class="headerlink" title="End-to-end, Hop-by-hop首部"></a>End-to-end, Hop-by-hop首部</h4><ul>
<li><p>End-to-end:</p>
<p>转发给最终接受目标</p>
<p>必须保存在缓存生成的响应中</p>
<p>必须被转发</p>
</li>
<li><p>Hop-by-hop</p>
<p>只对单次转发有效，通过缓存或代理则不再转发</p>
<p>需要提供Connection首部</p>
</li>
</ul>
<p>逐条首部字段：</p>
<ul>
<li>Connection</li>
<li>Keep-Alive</li>
<li>Proxy-Authentivate</li>
<li>Proxy-Authorization</li>
<li>Trailer</li>
<li>TE</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
<h3 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1815.24.39.png" alt="截屏2020-06-1815.24.39" style="zoom:50%;" />

<img src="/Users/yesun/Documents/study/笔记/博客/source/assets/截屏2020-06-1815.18.48.png" style="zoom:50%;" />



<img src="/Users/yesun/Desktop/截屏2020-10-12 15.05.50.png" style="zoom:50%;" />

<ul>
<li><p><strong>public</strong>：其他用户可以利用缓存</p>
</li>
<li><p><strong>private</strong>: 只有特定用户可以用缓存</p>
</li>
<li><p><strong>no-cache</strong>(不缓存过期资源): 客户端：我不要缓存过的，要从源服务器拿新的。服务器：你可以缓存，但使用前要先跟我确认。告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。</p>
</li>
<li><p><strong>no-store</strong>（不缓存）: 说明请求或响应中有机密信息，不能本地存储</p>
</li>
<li><p><strong>max-age</strong>: 客户端角度：要是缓存过期没超过一周，就把它给我。服务器角度：一周内不必再向我确认，你直接支配缓存。HTTP/1.1中，若Expires首部字段也存在，优先处理max-age，忽略Expires。HTTP/1.0则相反</p>
</li>
<li><p><strong>min-fresh</strong>: 至少在未来(s)秒内文档要保持新鲜。若min-fresh为60秒，过了60秒的资源都无法作为响应返回.</p>
</li>
<li><p><strong>max-stale</strong> ：过期后的 s 秒内缓存可以继续使用</p>
</li>
<li><p><strong>only-if-cached</strong>: 不用重新加载响应，也不用再次确认资源有效性，只返回已经缓存且满足要求的数据，否则的话返回 504 Gateway Timeout 错误。</p>
</li>
<li><p><strong>must-revalidate</strong>: 代理再次向服务器验证缓存是否仍然有效。若无法连接服务器，返回504。会忽略max-stale指令.告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。</p>
</li>
<li><p><strong>proxy-revalidate</strong>: 和 must-revalidate 类似，只是特定用于公共缓存的。</p>
</li>
</ul>
<p>PS：</p>
<ul>
<li><p><strong>max-age，max-stale 和 min-fresh 的关系</strong>：缓存使用期 age 表示缓存自 Server 将其发出（或最后一次被服务器再验证）之后过去的时间，则如果 age + min-fresh &lt; max-age，缓存未过期；如果 age + min-fresh &gt;= max-age &amp;&amp; age + min-fresh &lt; max-age + max-stale，则虽然缓存过期了，但是缓存继续可以使用，只是在头部添加 110 警告码；如果 age + min-fresh &gt;= max-age + max-stale，则缓存过期且不可使用。</p>
</li>
<li><p>对一条”HTTP GET”报文的<strong>基本缓存处理过程</strong>包括7个步骤：</p>
<ul>
<li><strong>接收</strong>—缓存从网络中读取抵达的请求报文；</li>
<li><strong>解析</strong>—缓存对报文进行解析，提取出URL和各种首部；</li>
<li><strong>查询</strong>—缓存查看是否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地)；</li>
<li><strong>新鲜度检测</strong>—缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新；</li>
<li><strong>创建响应</strong>—缓存会用新的首部和已缓存的主体来构建一条响应报文；</li>
<li><strong>发送</strong>—缓存通过网络将响应发回给客户端；</li>
<li><strong>日志</strong>—缓存可选地创建一个日志文件条目来描述这个事务。</li>
</ul>
</li>
<li><p><strong>保持副本的新鲜</strong>的机制：</p>
<ul>
<li><strong>文档过期</strong>：通过特殊的HTTP <strong>Cache-Control首部（max-age）和Expires首部</strong>，HTTP让原始服务器向每个文档附加了一个”过期日期”。这些首部说明了在多长时间内可以将这些内容视为新鲜的。在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系</li>
<li><strong>服务器再验证</strong>： 仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为”服务器再验证”，说明<strong>缓存需要询问原始服务器文档是否发生了变化</strong>。缓存并不一定要为每条请求验证文档的有效性——只有在文档过期时它才需要与服务器进行再验证。这样不会提供陈旧的内容，还可以节省服务器的流量，<ul>
<li>如果再验证显示内容<strong>发生了变化</strong>，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。</li>
<li>如果再验证显示内容<strong>没有发生变化</strong>，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>用条件方法进行再验证</strong></p>
<ul>
<li>缓存向原始服务器发送一个”<strong>条件GET</strong>“，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，<strong>将新鲜度检测和对象获取结合成了单个条件GET</strong>。</li>
<li><strong>If-Modified-Since： Date再验证</strong>：<ul>
<li>如果自指定日期后，文档被修改了，If-Modified-Since条件就为真，通常GET就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</li>
<li>如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回一个小的”304 Not Modified”响应报文，为了提高有效性，不会返回文档的主体。这 些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。一般会发送一个新的过期日期。</li>
</ul>
</li>
<li><strong>If-None-Match：实体标签再验证</strong>：有些情况下仅使用最后修改日期进行再验证是不够的。因此用<strong>Etag实体标签</strong>标识文档，实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文档的序列号或版本名。如果Etag被修改了，就重新GET<ul>
<li>有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。</li>
<li>有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。</li>
<li>有些服务器无法准确地判定其页面的最后修改日期。</li>
<li>有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>试探性过期</strong>：</p>
<ul>
<li>如果响应中没有”Cache-Control: max-age”首部，也没有Expires首部，缓存可以计算出一个试探性最大使用期。但如果得到的最大使用期大于24小时，就应该向响应首部添加一个Heuristic Expiration Warning(试探性过期警告，警告13)首部</li>
</ul>
</li>
</ul>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>两个作用：</p>
<ul>
<li><strong>控制不再转发给代理的首部字段</strong></li>
<li><strong>管理持久连接</strong></li>
</ul>
<h5 id="控制不再转发给代理的首部字段"><a href="#控制不再转发给代理的首部字段" class="headerlink" title="控制不再转发给代理的首部字段"></a>控制不再转发给代理的首部字段</h5><img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-12 15.19.59.png" alt="截屏2020-10-12 15.19.59" style="zoom:50%;" />

<h5 id="管理持久连接"><a href="#管理持久连接" class="headerlink" title="管理持久连接"></a>管理持久连接</h5><p>服务器发送Connection: close来关闭和客户端的持久连接</p>
<p>HTTP/1.1版本默认都是持久连接，1.0之前默认都是非持久连接，因此旧版本的HTTP协议上维持持续连接，就要指定Connection为Keep-Alive。</p>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>表明创建HTTP报文的日期和时间</p>
<h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>Trailer事先说明在报文主体后记录了那些首部字段，可用于在HTTP/1.1版本分块传输编码</p>
<h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>指定了传输报文主体时采用的编码方式。HTTP/1.1中仅对分块传输编码有效</p>
<h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>用于检测是否可使用更高版本进行通信，参数可以是一个完全不同的协议。</p>
<p>使用Upgrade时，还要指定Connection: Upgrade，让Upgrade仅作用于客户端和邻接服务器之间</p>
<h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>追踪请求和响应的传输路径。还可以避免请求回环的发生。</p>
<p>报文在经过代理和网关时，会在首部Via字段附加该服务器的信息，再转发。</p>
<h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-12 17.20.51.png" alt="截屏2020-10-12 17.20.51" style="zoom:50%;" />

<img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-12 17.21.35.png" alt="截屏2020-10-12 17.21.35" style="zoom:50%;" />

<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>通知服务器，用户代理能够处理的媒体类型和相对优先级。用q=来表示权重值</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>通知服务器用户支持的字符集和相对优先顺序，用q值表示权重。</p>
<p>用于内容协商机制的服务器驱动协商</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>告知服务器用户支持的内容编码及相对优先级。可以用q值</p>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>告知服务器用户支持的自然语言集和相对优先级。可以用q值</p>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>告知服务器用户的认证信息（证书值）。用户在接受到401 Unauthorized响应后，会把首部字段Authorization加入到请求中。</p>
<img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-12 17.30.54.png" style="zoom:50%;" />

<h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><p>告知服务器期望出现的某种特定行为。服务器无法理解时，返回417 Expectation Failed。比如客户端等待状态码100响应，就指定Expect: 100-continue</p>
<h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>告知服务器用户的电子邮件地址</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分。包含主机名和端口号。</p>
<p>Host首部字段是HTTP/1.1唯一一个必须被包含在请求内的首部字段。</p>
<h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>形如If-xxx的请求首部字段，都可称为条件请求。服务器接受到条件请求后，只有条件为真时，才会执行请求。</p>
<img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-12 17.38.53.png" alt="截屏2020-10-12 17.38.53" style="zoom:50%;" />

<p>If-Match告知服务器匹配资源的实体标记值ETag。若不匹配，服务器返回413 Precondition Failed。若使用*指定If-Match,就会忽略ETag,资源存在就处理请求。</p>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>如果在指定日期后，资源发生更新，服务器就接受请求，并返回最后一次更新的时间。否则返回304 Not Modified</p>
<h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>只有在字段值与ETag值不一致时，才处理该请求，与If-Match相反</p>
<p>GET或HEAD方法中使用If-None-Match可获取最新的资源，和If-Modified-Since类似。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。</p>
<h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 08.04.39.png"  />

<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 08.07.21.png)</p>
<p>如果不用If-Range，如果服务器资源更新，那客户端持有的资源的一部分也会无效，范围请求就会无效，服务器就会暂时返回412 Precondition Failed，催促客户端再次发送请求</p>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><p>和If-Modified-Since作用相反</p>
<h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><p>控制经过的转发服务器数。服务器转发请求时，Max-Forwards值-1，为0时不转发，直接返回响应。</p>
<p>当代理服务器转发请求失败时，客户端就得不到响应，可以用Max-Forwards来定位故障，了解传输路径的通信状况。</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>范围请求，请求指定字节范围的资源</p>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 08.16.23.png)*</p>
<p>告诉服务器请求的URI是从哪个Web页面发起的</p>
<p>但是如果直接在浏览器的地址栏输入URI，出于安全考虑，也可以不发送该首部字段。因为原始资源的URI中的查询字符串可能含有ID、密码等信息，要是写进Referer，可能会信息泄露。</p>
<h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><p>TE：gzip, deflate; q=0.5</p>
<p>告知服务器客户端能够处理的传输编码方式和相对优先级。</p>
<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 08.22.08.png)</p>
<p>将创建请求的浏览器、代理服务器等信息传给服务器</p>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p>两个值：bytes/none. 告诉客户端服务器是否能处理范围请求</p>
<h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>告知客户端，源服务器在多久前响应了，字段值为秒。若是缓存服务器创建了响应，</p>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>一种实体标识。将资源以字符串形式做唯一性标识。资源可以有相同的URI，但ETag不同。比如英文版google首页和中文版有相同URI，但有不同的ETag。</p>
<p>下载中断，再连接时，也会根据ETag来指定资源。</p>
<p><strong>强ETag和弱Etag</strong></p>
<ul>
<li>强ETag:不论实体发生多微小的变化，ETag值都会改变</li>
<li>弱ETag:只有资源发生根本改变时，才会改变ETag值。字段开始处附加W/</li>
</ul>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>把请求方引导至另外一个URI。配合3xx: Redirection，提供重定向的URI</p>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><p>客户端和代理之间的访问认证。把代理服务器要求的认证信息发送给客户端</p>
<h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><p>告知客户端多久之后再次发送请求。配合503 Service Unavailable响应或3xx Redirect响应</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>告知客户端服务器上HTTP服务器应用程序的信息，包括软件名称、版本号等</p>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 12.11.08.png)</p>
<p>Vary可对缓存进行控制。代理接收到源服务器返回包含Vary项到响应后，若再要进行缓存，只对请求包含相同Vary字段的请求返回缓存。即使对相同资源发起请求，如果Vary指定字段不同，代理也必须要从源服务器重新获取资源。</p>
<h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><p>用于HTTP访问认证。告知客户端适用于访问请求URI指定资源的认证方案（Basic/Digest）和带参数提示的质询（challenge）。401 Unauthorized响应中，肯定带有WWW-Authenticate字段</p>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>是包含在请求报文和响应报文的实体部分使用的首部，用于补充内容的更新时间等与实体相关的信息</p>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接受到不支持的HTTP方法时，返回405 Method Not Allowed响应，并把所有的支持的HTTP方法写入Allow后返回</p>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>告知客户端服务器对实体的主体采用的内容编码方式。</p>
<p><strong>内容编码</strong>：在不丢失实体信息前提下进行的压缩。</p>
<ul>
<li>gzip</li>
<li>compress</li>
<li>deflate</li>
<li>Identity</li>
</ul>
<p><strong>传输编码</strong>：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主题分块的功能称为分块传输编码。</p>
<h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>实体主体部分大小。对实体主体进行内容编码传输时，不能再使用Content-Length字段</p>
<h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><p>给出与报文主体对应的URI。请求URI可能与返回对象不同，比如使用首部字段Accept-Language的服务器驱动型请求。</p>
<h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 12.40.19.png" style="zoom:50%;" />

<p>一串由MD5算法生成的值，目的是检查报文主体是否保持完整</p>
<p>但是无法检测出内容的恶意篡改。因为如果内容被篡改了，Content-MD5也会重新计算并被篡改。</p>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p>针对范围请求，返回响应时使用Content-Range,告知客户端返回的实体哪个部分符合范围请求</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>将资源失效日期告知客户端。缓存服务器接受到含有Expires的响应后，用缓存来响应后面的请求。超过指定时间后，缓存服务器在接受到请求后，会转向源服务器请求资源。</p>
<p>源服务器不希望缓存服务器进行缓存时，应该在Expires字段写入和首部字段Date相同的时间值。</p>
<p>当首部字段Cache-Control指定了max-age时，优先处理max-age</p>
<h3 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h3><p>Cookie的工作机制是用户识别及状态管理。管理服务器和客户端之间的状态。</p>
<img src="/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-23 12.53.40.png" alt="截屏2020-10-23 12.53.40" style="zoom:50%;" />

<h4 id="Set-Cookie-各字段"><a href="#Set-Cookie-各字段" class="headerlink" title="Set-Cookie 各字段"></a>Set-Cookie 各字段</h4><ul>
<li><strong>expires</strong>: 指定浏览器可发送Cookie的有效期。默认有效期仅限于维持浏览器会话时间段内，即浏览器被关闭之前</li>
<li><strong>path</strong>：限制指定Cookie的发送范围的文件目录</li>
<li><strong>domain</strong>: 指定可以发送Cookie的域名结尾</li>
<li><strong>secure</strong>: 限制Web页面只在HTTPS安全连接时，才可以发送Cookie。否则服务器不会发生Cookie回收行为。</li>
<li><strong>HttpOnly</strong>: 使JavaScript脚本无法获得Cookie目的是防止跨站脚本攻击（XSS）窃取Cookie。</li>
</ul>
<p><strong>XSS攻击</strong>：它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。不同于大多数攻击(一般只涉及攻击者和受害者)，XSS 涉及到三方，即攻击者、客户端与Web应用。XSS 的攻击目标是为了盗取存储在客户端的 cookie 或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。<a href="https://www.jianshu.com/p/27da16438d15" target="_blank" rel="noopener">https://www.jianshu.com/p/27da16438d15</a></p>
<p><strong>总之，XSS 能做用户使用浏览器能做的一切事情。包括获取用户的 cookie 等重要隐私信息的操作。另外，同源策略无法保证不受 XSS 攻击，因为此时攻击者就在同源之内。</strong></p>
<ul>
<li>客户端型：<ul>
<li>客户端型 xss 攻击是一次性的，仅对当次的页面访问产生影响。客户端型 xss 攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</li>
</ul>
</li>
<li>服务端型<ul>
<li>本质上是注入攻击。区别在于服务端型的恶意代码可以复用，并且不需要引诱用户点击某个连接。黑客将将恶意代码通过某个操作，写入被攻击服务器的数据库中，接着在某个数据列表展示页面中通过嵌入 js 代码，迫使用户的浏览器执行恶意 javascript 代码来达到 XSS 攻击的目的。</li>
</ul>
</li>
</ul>
<h4 id="Cookie-字段"><a href="#Cookie-字段" class="headerlink" title="Cookie 字段"></a>Cookie 字段</h4><p>Cookie: status=enable</p>
<p>告知服务器，当客户端想获得HTTP状态管理支持时，会在请求中包含从服务器接受到的Cookie</p>
<h2 id="第7章-确保Web安全的HTTPS"><a href="#第7章-确保Web安全的HTTPS" class="headerlink" title="第7章 确保Web安全的HTTPS"></a>第7章 确保Web安全的HTTPS</h2><h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h3><ul>
<li>通信使用<strong>明文</strong>，内容可能被窃听</li>
<li>不验证<strong>通信方的身份</strong>，可能遭遇伪装</li>
<li>无法证明<strong>报文的完整性</strong>，可能已经被篡改</li>
</ul>
<h4 id="使用明文可能被窃听"><a href="#使用明文可能被窃听" class="headerlink" title="使用明文可能被窃听"></a>使用明文可能被窃听</h4><ul>
<li><p><strong>TCP/IP</strong>是可能被窃听的网络</p>
<p>互联网上的任何角落都存在通信内容被窃听的风险，抓包</p>
</li>
<li><p>加密处理防止被窃听</p>
<ul>
<li><p>通信的加密</p>
<p>用SSL建立安全通信线路后，就可以在其上进行HTTP通信了。SSL+HTTP=HTTPS</p>
</li>
<li><p>内容的加密</p>
<p>客户端需要对报文主体进行加密处理再发送。通信本身不会被加密。</p>
<p>要求客户端和服务器同时具备加密解密机制，但内容仍然有被篡改的风险</p>
</li>
</ul>
</li>
</ul>
<h4 id="不验证通信方的身份，可能遭遇伪装"><a href="#不验证通信方的身份，可能遭遇伪装" class="headerlink" title="不验证通信方的身份，可能遭遇伪装"></a>不验证通信方的身份，可能遭遇伪装</h4><ul>
<li><p>任何人都可发起请求</p>
<ul>
<li>无法确定请求发送的目标服务器是否是返回响应的服务器。可能是假服务器</li>
<li>无法确定响应返回到的客户端是否就是应该接受响应的客户端。可能是假客户端</li>
<li>无法确定对方是否具备访问权限。</li>
<li>无法判定请求是来自何方、出自谁手</li>
<li>即使是无意义的请求也会照单全收，无法阻止海量请求下的DoS攻击（Denial of Service 拒绝服务攻击）</li>
</ul>
</li>
<li><p>查明对手的证书</p>
<p>使用SSL就可以确定通信方。SSL不仅提供加密处理，还使用了证书，可用于确定通信方。</p>
</li>
</ul>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 13.58.36.png)</p>
<h4 id="无法证明报文完整性，可能已被篡改"><a href="#无法证明报文完整性，可能已被篡改" class="headerlink" title="无法证明报文完整性，可能已被篡改"></a>无法证明报文完整性，可能已被篡改</h4><ul>
<li><p>接收到的内容可能有误</p>
<p>没办法确认发出的就是接受到的。</p>
<p>像这样，请求或响应在传输途中，被拦截并篡改内容的攻击：<strong>中间人攻击</strong>（Man-in-the-Middle attack, <strong>MITM</strong>）</p>
</li>
<li><p>如何防止篡改</p>
<p>用MD5和SHA-1等散列值校验的方法，以及确认文件的数字签名</p>
<p>提供文件下载的网站也会提供响应的以PGP(Pretty Good Privacy，完美隐私)创建的数字签名和MD5算法生成的散列值。PGP是用来证明创建文件的数字签名，MD5是单向函数生成的散列值。</p>
<p>但是需要客户端用户本人亲自检查下载的文件是否是原文件，浏览器无法自动检查。而且没法百分百防止篡改，因为PGP和MD5本身也可能被篡改，而用户没办法觉察到。</p>
<p>所以需要使用HTTPS。SSL提供认证、加密处理、摘要功能。</p>
</li>
</ul>
<h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h3><p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.11.10.png)</p>
<h4 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h4><p>HTTP通信接口部分用SSL（Secure Socket Layer）和TLS(Transport Layer Security)协议代替</p>
<p>通常，HTTP直接和TCP通信。使用SSL时，则先和SSL通信，再由SSL和TCP通信。</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.13.55.png)</p>
<p>SSL是独立于HTTP的协议，因此不光是HTTP，其他运行在应用层的SMTP、Telnet等协议都可以配合SSL协议使用。是应用最为广泛的网络安全技术</p>
<h4 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h4><p>SSL采用<strong>公开密钥加密</strong>。加密算法是公开的，密钥却是保密的。</p>
<ul>
<li><p><strong>共享密钥加密</strong>的困境</p>
<p>加密和解密用同一个密钥，也叫做<strong>对称密钥加密</strong></p>
<p>用共享密钥加密时，密钥也必须发送给对方。密钥也可能被窃走。</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.19.31.png)</p>
</li>
<li><p>使用两把密钥的<strong>公开密钥加密</strong></p>
<p>公开密钥加密解决了这个问题。私有密钥+公有密钥。</p>
<p>发送方用接收方的公有密钥加密，接收方再用自己的私有密钥进行解密。</p>
<p>这样就不用发送用来解密的私有密钥，也不用担心密钥被盗走。而且想根据密文和公开密钥恢复信息是异常困难的。如果能对一个非常大的整数进行快速的因式分解，那么就可以破解密码，但是现在的技术是不现实的</p>
</li>
</ul>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.24.05.png)</p>
<ul>
<li><p>HTTPS采用<strong>混合加密机制</strong></p>
<p>若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密，但是公开密钥加密的处理速度要慢</p>
<p>因此，<strong>使用公开密钥加密交换密钥，使用共享密钥加密交换报文</strong></p>
</li>
</ul>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.28.15.png)</p>
<h4 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h4><p>但是公开密钥加密方式还是存在问题，无法证明公开密钥本身是货真价实的。即公开密钥的可靠性问题</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.43.02.png)</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 14.45.05.png)</p>
<p>公钥被调包，也是<strong>中间人攻击</strong></p>
<p>解决方法：使用由数字证书认证机构颁发的公开密钥证书。</p>
<p>该机构会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该密钥放入公钥证书后绑定在一起。</p>
<p>服务器会把这份公钥证书发送给客户端，来进行公开密钥加密通信。客户端接到证书后，可用数字认证机构的公开密钥，对证书的数字签名进行验证，验证通过后，客户端就可明确两件事：1. 认证服务器的公开密钥的是真实有效的认证机构。2. 服务器的公开密钥是值得信赖的。</p>
<p>此时认证机关的公开密钥必须安全地转交给客户端。多数浏览器会事先在内部植入常用认证机关的公开密钥。</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 16.42.11.png)</p>
<h4 id="用以确认客户端的客户端证书"><a href="#用以确认客户端的客户端证书" class="headerlink" title="用以确认客户端的客户端证书"></a>用以确认客户端的客户端证书</h4><p>证明服务器正在通信的对方是预料中的客户端。需要用户自行安装客户端证书，但是客户端证书是需要付费购买的。</p>
<p>例如银行的网上银行就采用了客户端证书。登陆网银时，不仅要求用户输入ID和密码，还会要求用户的客户端证书，来确认用户是否从特定终端访问网银。但不能证明用户本人的真实有效性，只要获得了安装有客户端证书的计算机的使用权限，就拥有了客户端证书的使用权限。</p>
<h4 id="认证机构信誉第一"><a href="#认证机构信誉第一" class="headerlink" title="认证机构信誉第一"></a>认证机构信誉第一</h4><p>SSL机制中介人认证机构之所以可行，是建立在其信用绝对可行这一前提下，但2011年7月，荷兰一家认证机构曾遭黑客入侵，颁布了google.com, twitter.com等网站的伪造证书。这一事件从根本上撼动了SSL的可信度。</p>
<h4 id="由自认证机构颁发的证书成为自签名证书"><a href="#由自认证机构颁发的证书成为自签名证书" class="headerlink" title="由自认证机构颁发的证书成为自签名证书"></a>由自认证机构颁发的证书成为自签名证书</h4><p>使用OpenSSL开源程序，每个人都可以构建一套自己的认证机构，然后自己给自己颁发证书，但不能在互联网上作为证书使用。浏览器访问这种服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”</p>
<h4 id="中级认证机构的证书可能会变成自认证证书"><a href="#中级认证机构的证书可能会变成自认证证书" class="headerlink" title="中级认证机构的证书可能会变成自认证证书"></a>中级认证机构的证书可能会变成自认证证书</h4><p>有的浏览器会把中级认证机构颁发的服务器证书当作自签名证书</p>
<h4 id="HTTPS的通信步骤"><a href="#HTTPS的通信步骤" class="headerlink" title="HTTPS的通信步骤"></a>HTTPS的通信步骤</h4><p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 17.03.04.png)</p>
<ol>
<li>客户端发送Client Hello开始SSL通信。包含客户端支持的SSL的指定版本、加密组件列表</li>
<li>服务器可进行SSL通信时，回应Server Hello报文，包含SSL版本和加密组件（从客户端列表中筛选出来的）</li>
<li>服务器发送Certificate报文，包含公开密钥证书</li>
<li>最后服务器发送 Server Hello Done通知客户端，最初的SSL握手协商部分结束</li>
<li>SSL第一次握手结束后，客户端以Client Key Exchange报文回应，包含通信加密中使用的称为Pre-master secret的随机密码串。该报文已经用步骤3中的公开密钥加密。</li>
<li>客户端继续发送Change Cipher Spec报文，提示服务器，此后的通信采用Pre-master secret密钥加密</li>
<li>客户端发送finished报文，包含连接至今全部报文的整体校验值。这次握手协商是否成功，要看服务器是否能正确解密该报文</li>
<li>服务器同样发送Changer Ciper Spec报文</li>
<li>服务器发送Finished报文</li>
<li>Finished报文交换完毕后，SSL连接就建立完成。此时开始应用层协议的通信，即HTTP请求</li>
<li>HTTP响应</li>
<li>最后由客户端断开连接。发送close notify报文。</li>
</ol>
<p>应用层发送数据时会附加<strong>MAC报文摘要</strong>，MAC能够查知报文是否被篡改，保护报文完整性。</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-25 17.20.32.png)</p>
<h4 id="SSL速度慢吗"><a href="#SSL速度慢吗" class="headerlink" title="SSL速度慢吗"></a>SSL速度慢吗</h4><p>HTTPS的问题：使用SSL时，速度会变慢。<strong>通信慢</strong>（SSL通信量）+<strong>处理速度慢</strong>（加密解密消耗CPU和内存资源）</p>
<p>因此很多网站不会一直使用HTTPS：消耗太多资源，能够处理的请求亮就会减少。因此非敏感信息使用HTTP，只有包含个人信息等数据时，才使用HTTPS。而且可以节约购买证书等开销</p>
<h2 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h2><h3 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h3><p>确认网络那头到底是谁。核对“登陆者本人才有的信息”：</p>
<ul>
<li>密码</li>
<li>动态令牌：仅限本人持有的设备内的一次性密码</li>
<li>数字证书：仅限本人终端持有的信息</li>
<li>生物认证：指纹、虹膜</li>
<li>IC卡</li>
</ul>
<p>HTTP使用的认证方式：</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
<h3 id="BASIC认证"><a href="#BASIC认证" class="headerlink" title="BASIC认证"></a>BASIC认证</h3><p>仍有一部分网站会使用这种认证方式。Web服务器和通信客户端之间的认证方式</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 10.26.51.png)</p>
<p>BASIC认证虽然采用Base64编码，但<strong>不是加密</strong>， 不需要额外信息就可以对其解码。因此在HTTP等非加密通信等线路上进行BASIC认证，如果被窃听，被盗的可能性极高。</p>
<h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><p>弥补BASIC认证的缺点。同样适用质询/响应的方式，但不会发送明文密码。安全等级高于BASiC，但仍然弱于HTPS的客户端认证。DIGEST提供防治密码被窃听的机制，但<strong>不提供防止用户伪装的保护机制</strong></p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 10.31.08.png)</p>
<h3 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h3><p>SSL客户端认证利用HTTPS的客户端证书完成认证。</p>
<h4 id="SSL客户端认证步骤"><a href="#SSL客户端认证步骤" class="headerlink" title="SSL客户端认证步骤"></a>SSL客户端认证步骤</h4><ul>
<li>接受到对需要认证资源的请求，服务器发送Certificate Request报文，要求客户端提供客户端证书</li>
<li>用户选择客户端证书，客户端把证书以Client Certificate报文发送给服务器</li>
<li>服务器验证客户端证书。通过后领取证书内客户端的公开密钥，开始HTTPS加密通信</li>
</ul>
<h4 id="SSL客户端采用双因素认证"><a href="#SSL客户端采用双因素认证" class="headerlink" title="SSL客户端采用双因素认证"></a>SSL客户端采用双因素认证</h4><p>SSL客户端证书用来认证客户端计算机，基于表单认证（密码）用来确定这是用户本人</p>
<h3 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h3><p>并没有在HTTP协议里定义。客户端向服务器发送登录信息。如登录页面输入用户名、密码。</p>
<h4 id="认证多半为基于表单认证"><a href="#认证多半为基于表单认证" class="headerlink" title="认证多半为基于表单认证"></a>认证多半为基于表单认证</h4><p>由于便利性和安全性问题，BASIC和DIGEST几乎不怎么使用。SSL客户端因为导入和费用问题，也没有普及</p>
<p>基于表单认证的安全等级完全依赖于各Web应用程序的实现方式</p>
<h4 id="Session管理和Cookie应用"><a href="#Session管理和Cookie应用" class="headerlink" title="Session管理和Cookie应用"></a>Session管理和Cookie应用</h4><p>基于表单认证还没有标准规范，一般使用Cookie来管理Session。</p>
<p>但是HTTP是无状态协议，已认证成功的用户状态无法通过协议层面保存下来。因此使用Cookie来管理Session,弥补HTTP协议中不存在的状态管理功能。</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 10.50.13.png)</p>
<ol>
<li>客户端把用户ID和密码等信息放入报文的实体部分，以POST方法发送请求。使用HTTPS通信</li>
<li>服务器发放用来识别用户的SessionID。验证客户端发送过来的登陆信息进行身份认证，然后把认证状态和SessionID绑定记录在服务器端。通过Set-Cookie字段写入Session ID。但是如果SessionID被盗，对方就可以伪装成你进行恶意操作了。因此必须防止Session ID被盗。因此Session ID应使用难以推测的字符串，而且服务器也需要做有效期管理。还应在Cookie里加上httponly属性，减轻跨站脚本攻击（XSS）损失</li>
<li>客户端接收到Session ID后，作为cookie保存在本地。下次再发送请求时，浏览器自动发送Cookie，因此Session ID也会发送到服务器。服务器通过Session ID识别用户和其认证状态。</li>
</ol>
<p>不仅基于表单认证的登陆信息和认证过程没有标准化，服务器如何保存用户提交的密码等登陆信息也没有标准化</p>
<p>一种安全的保存方法是：<strong>密码加盐</strong>（密码拼接一个足够长的随机字符串），再<strong>使用散列函数计算散列值后保存</strong>。减少密码泄漏的风险</p>
<h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="消除HTTP瓶颈的SPDY"><a href="#消除HTTP瓶颈的SPDY" class="headerlink" title="消除HTTP瓶颈的SPDY"></a>消除HTTP瓶颈的SPDY</h3><p>Google 在2010年发不了SPDY，开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间50%</p>
<h4 id="HTTP的瓶颈"><a href="#HTTP的瓶颈" class="headerlink" title="HTTP的瓶颈"></a>HTTP的瓶颈</h4><p>如果要<strong>探知服务器是否有内容更新</strong>，客户端就必须频繁地向服务器确认。如果没有内容更新，就会有大量<strong>无效通信</strong></p>
<ul>
<li>一条连接只可发送一个请求</li>
<li>请求只能从客户端开始</li>
<li>请求/响应首部未经压缩就发送。首部信息越多延迟越大</li>
<li>每次互相发送冗长的首部造成的浪费较多</li>
<li>非强制压缩发送</li>
</ul>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 11.05.57.png)</p>
<p><strong>Ajax的解决方法</strong></p>
<p>Ajex(Asynchronous JavaScript and XML)是一种有效<strong>利用JavaScript和DOM</strong>的操作，以达到<strong>局部Web页面替换加载</strong>的<strong>异步通信</strong>手段。响应中的数据量会减少。可以从已加载完成的Web页面上发起请求，只更新局部页面。</p>
<p>但是利用Ajex实时地从服务器获取内容，可能会产生大量请求。也没有解决HTTP协议本身的问题</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 11.11.02.png)</p>
<p><strong>Comet的解决方法</strong></p>
<p>通过延迟应答，模拟实现服务器端向客户端push的功能。</p>
<p>减少了请求数，但一次连接的持续时间变长了，为了维持连接会消耗更多的资源。也没有解决HTTP协议本身的问题</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 11.14.17.png)</p>
<p><strong>SPDY的目标</strong></p>
<p>在协议级别消除HTTP的瓶颈</p>
<h4 id="SPDY的设计和功能"><a href="#SPDY的设计和功能" class="headerlink" title="SPDY的设计和功能"></a>SPDY的设计和功能</h4><p>在应用层和运输层之间添加会话层，并且规定通信使用SSL。SPDY以会话层形式加入，控制数据的流动，但还是采用HTTP建立通信连接，因此可照常使用HTTP的GET、POST等方法、Cookie等</p>
<p>![](/Users/yesun/Documents/screenshots/笔记/图解http/截屏2020-10-27 11.19.07.png)</p>
<p>使用SPDY后，HTTP额外获得以下功能：</p>
<ul>
<li><strong>多路复用流</strong>： 通过单一的TCP连接，可以无限制处理多个HTTP请求</li>
<li><strong>赋予请求优先级</strong>：解决在发送多个请求时，因带宽低而响应变慢的问题</li>
<li><strong>压缩HTTP首部</strong>：减少数据报数量和发送字节数</li>
<li><strong>推送功能</strong>：服务器可以直接给客户端push数据</li>
<li><strong>服务器提示功能</strong>：服务器可以主动提示客户端请求所需的资源。</li>
</ul>
<h4 id="SPDY消除Web瓶颈了吗"><a href="#SPDY消除Web瓶颈了吗" class="headerlink" title="SPDY消除Web瓶颈了吗"></a>SPDY消除Web瓶颈了吗</h4><p>使用SPDY时，Web内容不需要改动，但Web浏览器和服务器需要改。已经有好几家Web浏览器针对SPDY作出了调整。Web服务器也做了实验性质的应用，但导入实际应用进展不佳。</p>
<p>因为SPDY只是将单个域名（IP地址）的通信多路复用，所以当Web网站使用多个域名下的资源时，改善效果会受限制。</p>
<p>SPDY的确可以消除HTTP瓶颈，但是这不是Web瓶颈的唯一问题。还应从改善Web网站内容的编写方式等入手</p>
<h3 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h3><p>利用Ajax和Comet通信可以提升Web的浏览速度，但是只要使用HTTP就无法彻底解决瓶颈问题。因此有了WebSocket，一套新协议和API</p>
<h4 id="WebSocket的设计和功能"><a href="#WebSocket的设计和功能" class="headerlink" title="WebSocket的设计和功能"></a>WebSocket的设计和功能</h4><p>为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题</p>
<h4 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h4><p>建立在HTTP基础上，连接的发起方仍然时客户端，而连接一旦建立，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<ul>
<li><strong>推送功能</strong></li>
<li><strong>减少通信量</strong> 连接的开销减少，WebSocket的首部也很小</li>
</ul>
<p>为了实现WebSocket</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/KM%E7%AC%94%E8%AE%B0%20--%20%E6%B5%B7%E9%87%8F%E4%B9%8B%E9%81%93%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/KM%E7%AC%94%E8%AE%B0%20--%20%E6%B5%B7%E9%87%8F%E4%B9%8B%E9%81%93%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/" itemprop="url">KM笔记 -- 海量之道系列之过载保护</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-21T04:03:23+02:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="KM笔记-–-海量之道系列之过载保护"><a href="#KM笔记-–-海量之道系列之过载保护" class="headerlink" title="KM笔记 – 海量之道系列之过载保护"></a>KM笔记 – 海量之道系列之过载保护</h1><p>过载保护是<strong>有损服务方法论</strong>之一。海量之道两大技术价值观：<strong>有损服务</strong>，<strong>动态运营</strong></p>
<h2 id="系统过载的后果"><a href="#系统过载的后果" class="headerlink" title="系统过载的后果"></a>系统过载的后果</h2><ul>
<li>分布式集群系统中，某台设备故障，造成系统<strong>整体繁忙不可用</strong></li>
<li>营销推广时，某个服务单元负载极大的现象会很快<strong>蔓延</strong></li>
<li>用户群越大，系统规模越大，<strong>蔓延速度</strong>就越快</li>
</ul>
<p>系统开始分布后，规模扩张后，<u>单点平衡破坏后的<strong>传播和放大效应</strong></u>才是致命因素</p>
<h2 id="系统过载的成因"><a href="#系统过载的成因" class="headerlink" title="系统过载的成因"></a>系统过载的成因</h2><p>四种瓶颈：</p>
<ul>
<li>CPU： 计算密集型</li>
<li>Memory： 内存消耗型</li>
<li>Load： 大并发型</li>
<li>IO： 磁盘IO密集型，网络IO密集型</li>
</ul>
<p><strong>为什么过载会传播和放大？</strong></p>
<p>比如北京奥运门票销售事件，卖出9000张票，平均每个用户请求了60次。 </p>
<p>后端某个单元过载响应变慢 -&gt; 用户失去耐心重新刷新请求 -&gt; 大量无效请求负载均衡到其他逻辑单元 -&gt; 其他逻辑单元过载 -&gt; 整个系统崩溃。</p>
<h2 id="系统过载的保护"><a href="#系统过载的保护" class="headerlink" title="系统过载的保护"></a>系统过载的保护</h2><h3 id="四个方法"><a href="#四个方法" class="headerlink" title="四个方法"></a>四个方法</h3><h4 id="轻重分离"><a href="#轻重分离" class="headerlink" title="轻重分离"></a>轻重分离</h4><p>细分服务内容，<strong>高内聚低耦合</strong>，在突发流量不可控的前提下实现<strong>系统影响面的可控</strong>。 最理想的情况：物理上隔离（服务器、IDC、带宽等）</p>
<p>具体实现方法：</p>
<ul>
<li><strong>渠道分离</strong>：有线、无线服务分离</li>
<li><strong>部署分离</strong>：电信、联通、海外服务的分离</li>
<li><strong>快慢分离</strong>：图片、视频、下载等服务的分离</li>
<li><strong>用户分离</strong>：按set划分系统为用户提供服务</li>
</ul>
<h4 id="及早拒绝"><a href="#及早拒绝" class="headerlink" title="及早拒绝"></a>及早拒绝</h4><p>理论基础：问题解决的阶段越早，成本越低。<strong>前端保护后端，后端不信任前端</strong></p>
<ul>
<li>实时（秒级）地了解当前负载情况。后端将负载情况上报给前端，负载状态数据应在系统各层级见有后向前流动</li>
<li>前端分发请求时，根据负载情况去调度，必要时拒绝。<strong>前端保护后端</strong></li>
<li>后端也要有机制在超过负载时拒绝请求，<strong>后端不信任前端</strong></li>
</ul>
<p>注意：所有独立单元、集成系统都要做<strong>benchmark</strong>(基准)，识别慢速系统</p>
<h4 id="量力而为"><a href="#量力而为" class="headerlink" title="量力而为"></a>量力而为</h4><p>各层级先做好自我保护，再考虑对关联系统的保护</p>
<p>容量管理和过载保护机制的启动不能按100%计算单box的负载，此时已经出现拐点，进入过载状态。建议<strong>容量按70%预警</strong>，<strong>过载保护90%启动</strong>。</p>
<h4 id="动态调节"><a href="#动态调节" class="headerlink" title="动态调节"></a>动态调节</h4><p>联动性质的过载保护。核心思想：运营时通过持续监控业务状态数据<strong>寻找平衡点，正向动态反馈</strong>。</p>
<p>系统三个状态循环：<strong>正常状态-&gt;过载保护-&gt;灰度恢复-&gt;正常状态</strong></p>
<h2 id="过载保护的两个误区"><a href="#过载保护的两个误区" class="headerlink" title="过载保护的两个误区"></a>过载保护的两个误区</h2><h3 id="有了负载均衡LB和容灾（HA），不需要过载保护"><a href="#有了负载均衡LB和容灾（HA），不需要过载保护" class="headerlink" title="有了负载均衡LB和容灾（HA），不需要过载保护"></a>有了负载均衡LB和容灾（HA），不需要过载保护</h3><p>LB和容灾解决了大容量业务的平行扩展和可用性问题，有一定应对突发流量的能力。但是<u>LB只做到流量的均衡分布处理，没有实现流量超出系统总体容量时的保护、控制.</u></p>
<h3 id="有了请求队列，不需要过载保护"><a href="#有了请求队列，不需要过载保护" class="headerlink" title="有了请求队列，不需要过载保护"></a>有了请求队列，不需要过载保护</h3><p>请求队列的目的是通过非阻塞方式实现异步系统，提升系统处理能力，是系统性能提升之道。</p>
<p>但是请求队列<strong>无法及时剔除无效请求</strong>，<strong>无法控制雪球的增长，无法控制过载的扩散</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="叶子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/Avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="叶子冲冲冲">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E7%AF%87/" itemprop="url">面试题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-01T19:53:45+02:00">
                2020-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java容器有哪些？哪些是同步容器-哪些是并发容器？"><a href="#Java容器有哪些？哪些是同步容器-哪些是并发容器？" class="headerlink" title="Java容器有哪些？哪些是同步容器,哪些是并发容器？"></a>Java容器有哪些？哪些是同步容器,哪些是并发容器？</h2><p>容器，两个接口，Collection, Map</p>
<ul>
<li><p><strong>Collection</strong></p>
</li>
<li><p><strong>List</strong></p>
</li>
<li><p><strong>LinkedList</strong>: <strong>双向链表</strong>，<strong>顺序访问</strong>，<strong>快速中间插入和删除</strong>元素。可以用<strong>作栈、队列和双向队列。</strong></p>
</li>
<li><p><strong>ArrayList</strong>: 基于<strong>动态数组</strong>实现，支持<strong>随机访问</strong></p>
</li>
<li><p><strong>Vector</strong>: 和<strong>ArrayList</strong> 类似，但它是<strong>线程安全</strong>的</p>
</li>
<li><p>Stack</p>
</li>
<li><p><strong>Set</strong></p>
</li>
<li><p><strong>HashSet</strong>：<strong>哈希表</strong>，<strong>快速查找</strong>，<strong>不支持有序性</strong>，<strong>失去插入顺序</strong></p>
</li>
<li><p><strong>TreeSet</strong>: <strong>红黑树</strong>,<strong>有序性</strong>，例如<strong>根据一个范围查找元素</strong>的操作。<strong>查找效率</strong>不如 <strong>HashSet O(1)，TreeSet O(logN)</strong>.TreeSet 还实现了 SortedSet 接口</p>
</li>
<li><p><strong>LinkedHashSet</strong>：<strong>双向链表</strong>， HashSet 的查找效率，<strong>维护插入顺序</strong>。</p>
</li>
<li><p><strong>Queue</strong></p>
</li>
<li><p><strong>LinkedList</strong> 可以实现双向队列</p>
</li>
<li><p><strong>PriorityQueue</strong> 堆，可以实现优先队列</p>
</li>
<li><p><strong>Map</strong></p>
</li>
<li><p><strong>TreeMap</strong>: <strong>红黑树</strong></p>
</li>
<li><p><strong>HashTable</strong> <strong>哈希表</strong> <strong>线程安全</strong> <strong>遗留类</strong> <strong>使用ConcurrentHashMap,使用了分段锁，效率高</strong></p>
</li>
<li><p><strong>HashMap</strong>： <strong>哈希表</strong></p>
</li>
<li><p><strong>LinkedHashMap</strong> <strong>双向链表</strong> <strong>维护插入顺序或LRU顺序</strong></p>
</li>
</ul>
<h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><p><strong>synchronized关键字修饰</strong>容器保证<strong>同一时刻内只有一个线程在使用容器</strong>。多线程变为串行。<strong>复合操作不能保证线程安全</strong>。举例：A线程第一步获取尾节点，第二步将尾结点的值加1，但在A线程执行完第一步的时候，B线程删除了尾节点，在A线程执行第二步的时候就会报空指针）</p>
<ul>
<li><p><strong>Vector</strong></p>
</li>
<li><p><strong>Stack</strong></p>
</li>
<li><p><strong>HashTable</strong></p>
</li>
<li><p><strong>Collections.synchronized方法生成</strong></p>
</li>
</ul>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>允许<strong>多线程同时使用</strong>容器，并且保证线程安全。<strong>锁、CAS（无锁）、COW（读写分离）、分段锁</strong>。</p>
<p><strong>分段锁</strong>：容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争</p>
<p><strong>COW</strong>：<strong>写复制的数组</strong>上进行，<strong>读原始数组</strong>，读写分离，互不影响。<strong>写操作需要加锁</strong>，防止并发写入时导致写入数据丢失。原始数组指向新的复制数组。</p>
<ul>
<li><p><strong>ConcurrentHashMap</strong>：线程安全的HashMap的实现，<strong>1.7分段锁</strong>。 <strong>1.8CAS 红黑树</strong> 更高的并发度，失败时使用内置锁synchronized。1.8会转换为红黑树。</p>
</li>
<li><p><strong>CopyOnWriteArrayList</strong>：线程安全且在<strong>读操作时无锁</strong>的ArrayList。<strong>适合读多写少</strong>。缺陷：写操作复制<strong>占用内存</strong>，<strong>不能读取实时性数据</strong>。不适合：内存敏感，对实时性要求高</p>
</li>
<li><p><strong>CopyOnWriteArraySet</strong>：基于CopyOnWriteArrayList，不添加重复元素</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong>：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue</p>
</li>
</ul>
<h2 id="ArrayList和LinkedList的插入和访问的时间复杂度？"><a href="#ArrayList和LinkedList的插入和访问的时间复杂度？" class="headerlink" title="ArrayList和LinkedList的插入和访问的时间复杂度？"></a>ArrayList和LinkedList的插入和访问的时间复杂度？</h2><p>ArrayList 插入O(n)和O(1),删除O(n),访问O(1)</p>
<p>LinkedList 插入O(n)和O(1),删除O(1),访问O(n)</p>
<h2 id="Java反射原理-注解原理？"><a href="#Java反射原理-注解原理？" class="headerlink" title="Java反射原理,注解原理？"></a>Java反射原理,注解原理？</h2><p> 反射</p>
<h3 id="反射获取对象的步骤"><a href="#反射获取对象的步骤" class="headerlink" title="反射获取对象的步骤"></a>反射获取对象的步骤</h3><ul>
<li><p>获取类的 <strong>Class 对象实例</strong></p>
</li>
<li><p>根据 Class 对象实例获取** Constructor 对象**</p>
</li>
<li><p>使用 Constructor 对象的 <strong>newInstance 方法</strong>获取反射类对象</p>
</li>
</ul>
<h3 id="反射调用方法步骤"><a href="#反射调用方法步骤" class="headerlink" title="反射调用方法步骤"></a>反射调用方法步骤</h3><p><strong>反射</strong>就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法</p>
<ul>
<li><p>获取类的 <strong>Class 对象实例</strong></p>
</li>
<li><p>获取方法的 <strong>Method 对象</strong></p>
</li>
<li><p>利用 <strong>invoke 方法</strong>调用方法</p>
</li>
</ul>
<h3 id="反射调用方法实现原理"><a href="#反射调用方法实现原理" class="headerlink" title="反射调用方法实现原理"></a>反射调用方法实现原理</h3><ol>
<li><p>缓存或JVM中获取该Class中申明的方法列表</p>
</li>
<li><p>从返回的方法列表里找到一个匹配名称和参数的方法对象</p>
</li>
<li><p>如果找到一个匹配的Method，则重新copy一份返回。新对象的root属性都指向原来的Method对象，如果需要频繁调用，最好把Method对象缓存起来。</p>
</li>
</ol>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解的本质就是一个<strong>继承了 Annotation 接口的接口</strong></p>
<p>元注解』是用于修饰注解的注解，通常用在注解的定义上，指定某个注解生命周期以及作用目标等信息。</p>
<ol>
<li><p>首先，我们通过<strong>键值对的形式可以为注解属性赋值</strong>，像这样：@Hello（value = “hello”）。</p>
</li>
<li><p>接着，你用注解修饰某个元素，<strong>编译器</strong>将在编译期扫描每个类或者方法上的注解，会做一个基本的 <strong>检查</strong>，你的这个注解<strong>是否允许作用</strong>在当前位置，最后会<strong>将注解信息写入元素的属性表</strong>。</p>
</li>
<li><p>然后，当你<strong>进行反射的时候</strong>，虚拟机将所有<strong>生命周期在 RUNTIME 的注解取出</strong>来放到一个 <strong>map</strong> 中，并创建一个 <strong>AnnotationInvocationHandler</strong> 实例，把这个 <strong>map 传递给它</strong>。</p>
</li>
<li><p>最后，虚拟机将采用 <strong>JDK 动态代理机制生成一个目标注解的代理类</strong>，并初始化好处理器。</p>
</li>
</ol>
<p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，</p>
<h2 id="新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？"><a href="#新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？" class="headerlink" title="新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？"></a>新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？</h2><h3 id="一个Elden区和两个Survivor（幸存）区。"><a href="#一个Elden区和两个Survivor（幸存）区。" class="headerlink" title="一个Elden区和两个Survivor（幸存）区。"></a>一个Elden区和两个Survivor（幸存）区。</h3><p>在GC中，Eden中的对象会被移动到survivor中，直至对象满足一定的年纪（定义为熬过minor GC的次数），会被移动到老年代。</p>
<h3 id="新生代采取复制算法，"><a href="#新生代采取复制算法，" class="headerlink" title="新生代采取复制算法，"></a>新生代采取<strong>复制算法</strong>，</h3><ol>
<li><p>在Minor GC之前，<strong>to survivor区域保持清空</strong>，对象保存在Eden和from survivor区，</p>
</li>
<li><p>minor GC运行时，<strong>Eden中的幸存对象会被复制到to Survivor</strong>（同时对象年龄会增加1）。<strong>from survivor区，年龄没达到阈值，复制到to survivor中，否则移到老年代</strong>。 Eden和From幸存区可以视为清空。</p>
</li>
<li><p><strong>若to幸存区被填满了，放到老年代</strong>。</p>
</li>
<li><p>From survivor和to survivor会<strong>调换一下名字</strong></p>
</li>
</ol>
<p>对象一般出生在Eden区，年轻代GC过程中，对象在2个幸存区之间移动，如果对象活到适当的年龄，会被移到老年代</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p><strong>优化GC性能</strong></p>
<p>新生代需要清理的对象数量十分巨大，复制算法<strong>不需要移动待回收对象</strong>，直接将存活对象复制到另一块空闲内存区域中，<strong>减小了时间复杂度</strong></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="在什么情况下会扩容？"><a href="#在什么情况下会扩容？" class="headerlink" title="在什么情况下会扩容？"></a>在什么情况下会扩容？</h3><p>size 大于等于 threshold 就必须进行扩容操作</p>
<p>threshold = (int)(capacity* loadFactor)</p>
<h3 id="HashMap-put方法的执行过程？"><a href="#HashMap-put方法的执行过程？" class="headerlink" title="HashMap put方法的执行过程？"></a>HashMap put方法的执行过程？</h3><ol>
<li><p>若键为null，使用第 0 个桶存放键为 null 的键值对</p>
</li>
<li><p>求key值的hash</p>
</li>
<li><p>根据hash计算桶下标。hash%capacity。如果能保证capacity为2的n次方，h&amp;(capacity-1)</p>
</li>
<li><p>是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</p>
</li>
<li><p>插入新键值对。头插法（1.7之前）尾插法(1.7之后)。</p>
</li>
</ol>
<h3 id="HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？"><a href="#HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？" class="headerlink" title="HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？"></a>HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？</h3><p>在jdk1.8之前是插入头部的，在jdk1.8中是插入尾部的。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>红黑树的特性:</p>
<ul>
<li><p>每个节点<strong>或黑色或红</strong>。</p>
</li>
<li><p><strong>根节点和每个叶子节点（NIL）是黑色</strong>。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p>
</li>
<li><p><strong>父红子黑</strong>。</p>
</li>
<li><p><strong>父到子孙</strong>的所有路径上包含<strong>相同数目的黑节点</strong>。</p>
</li>
</ul>
<h3 id="为什么用红黑树"><a href="#为什么用红黑树" class="headerlink" title="为什么用红黑树"></a>为什么用红黑树</h3><p>在<strong>CurrentHashMap</strong>中是<strong>加锁</strong>了的，实际上是读写锁，如果<strong>写冲突就会等待</strong>，</p>
<p>如果插入时间过长必然等待时间更长，而<strong>红黑树的插入</strong>更快！插入和删除方面，AVL树速度较慢：需要<strong>更高的旋转次数</strong>才能重新平衡数据结构。</p>
<p>BST：</p>
<ul>
<li><p>查找 lgn n</p>
</li>
<li><p>插入 lgn</p>
</li>
<li><p>删除 lgn</p>
</li>
</ul>
<p>AVL：</p>
<ul>
<li><p>查找 lgn</p>
</li>
<li><p>插入 lgn</p>
</li>
<li><p><strong>删除 2lgn</strong> (删除后还有lgn次旋转)</p>
</li>
</ul>
<p>红黑树：</p>
<ul>
<li><p>查找 lgn</p>
</li>
<li><p>插入 lgn</p>
</li>
<li><p><strong>删除 lgn + 3</strong>(3次旋转)</p>
</li>
</ul>
<p>红黑树对比AVL树：</p>
<ul>
<li><p>AVL树严格平衡，和B树一样适合查找密集型数据</p>
</li>
<li><p>红黑树适合插入密集型。插入，删除，查找性能好</p>
</li>
</ul>
<h3 id="相比于BST和AVL树有什么优点"><a href="#相比于BST和AVL树有什么优点" class="headerlink" title="相比于BST和AVL树有什么优点"></a>相比于BST和AVL树有什么优点</h3><ul>
<li><p>它的<strong>查找效果是有最低保证</strong>的。在最坏的情况下也可以保证O(logN)，好于二叉查找树的。</p>
</li>
<li><p><strong>删除操作代价低</strong></p>
</li>
</ul>
<h2 id="https和http区别"><a href="#https和http区别" class="headerlink" title="https和http区别"></a>https和http区别</h2><p>HTTP 有以下安全性问题：</p>
<ul>
<li><p>使用明文进行通信，内容可能会被<strong>窃听</strong>；</p>
</li>
<li><p>不验证通信方的身份，通信方的身份有可能遭遇<strong>伪装</strong>；</p>
</li>
<li><p>无法证明报文的完整性，<strong>报文有可能遭篡改</strong></p>
</li>
</ul>
<p>HTTPS 具有了<strong>加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong>。</p>
<p><strong>混合加密机制</strong>：使用对称加密机制，但是用非对称加密机制加密密钥。</p>
<p><strong>CA认证机制</strong>： 向CA提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><img src="/assets/截屏2020-03-2917.44.30.png" style="zoom:50%;" />

<p><strong>主要参数：</strong></p>
<ul>
<li><p>corePoolSize</p>
</li>
<li><p>maxPoolSize</p>
</li>
<li><p>keepAliveTime</p>
<p>当线程<strong>空闲时间达到keepAliveTime，该线程会退出</strong>，直到线程<strong>数量等于corePoolSize</strong>。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。</p>
</li>
<li><p>allowCoreThreadTimeout</p>
<p>是否允许核心线程空闲退出，默认值为false。</p>
</li>
<li><p>queueCapacity</p>
<p>任务队列容量</p>
</li>
</ul>
<p><strong>如何来设置：</strong></p>
<p>需要根据几个值来决定</p>
<ul>
<li><p><strong>tasks</strong> ：每秒的任务数，假设为500~1000</p>
</li>
<li><p><strong>taskcost</strong>：每个任务花费时间，假设为0.1s</p>
</li>
<li><p><strong>responsetime</strong>：系统允许容忍的最大响应时间，假设为1s</p>
</li>
</ul>
<p>做几个计算</p>
<ul>
<li>corePoolSize = 每秒需要多少个线程处理？</li>
</ul>
<ul>
<li><p><strong>threadcount = tasks/(1/taskcost)</strong> =tasks<em>taskcout = (500~1000)</em>0.1 = 50~100 个线程。corePoolSize设置应该大于50</p>
</li>
<li><p>根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可</p>
</li>
</ul>
<p>- queueCapacity = (coreSizePool/taskcost)*responsetime</p>
<ul>
<li><p>计算可得 queueCapacity = 80/0.1*1 = 800。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行</p>
</li>
<li><p>切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增</p>
</li>
</ul>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ul>
<li><p>AbortPolicy</p>
<p>丢弃任务并抛出RejectedExecutionException异常。</p>
</li>
<li><p>DiscardPolicy</p>
<p>丢弃任务，不抛出异常</p>
</li>
<li><p>DiscardOldestPolicy</p>
<p>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p>
</li>
<li><p>CallerRunsPolicy</p>
<p>由调用线程处理该任务</p>
</li>
<li><p>用户自定义拒绝策略（最常用）</p>
<p>实现RejectedExecutionHandler，并自己定义策略模式</p>
</li>
</ul>
<h2 id="Linux怎么查看系统负载情况"><a href="#Linux怎么查看系统负载情况" class="headerlink" title="Linux怎么查看系统负载情况"></a>Linux怎么查看系统负载情况</h2><p>Linux的负载高，主要是由于<strong>CPU使用、内存使用、IO消耗</strong>三部分构成</p>
<p><strong>w或者uptime</strong></p>
<p><strong>top命令</strong>能够清晰的展现出系统的状态，而且它是实时的监控</p>
<h2 id="springmvc处理请求全流程"><a href="#springmvc处理请求全流程" class="headerlink" title="springmvc处理请求全流程"></a>springmvc处理请求全流程</h2><ol>
<li><p><strong>请求从浏览器到达DispatcherServlet</strong>。DispatcherServlet是一个<strong>单例的前端控制器</strong>（所有的请求都通过前端控制器）。它的任务是把<strong>请求发给SpringMVC控制器</strong></p>
</li>
<li><p><strong>确定处理请求的控制器</strong>。<strong>处理器映射</strong>会根据URL信息来决策</p>
</li>
<li><p><strong>DispatcherServelet</strong>将<strong>请求发给控制器</strong>，请求卸下负载。</p>
</li>
<li><p>控制器将<strong>产生的模型数据</strong>打包，标示出用于<strong>渲染的视图名</strong>。将请求、模型、逻辑视图名<strong>返回DispatcherServlet</strong>。</p>
</li>
<li><p>DispatcherServlet<strong>使用视图解析器将逻辑视图名匹配为一个特定视图</strong></p>
</li>
<li><p>DispatcherServlet将<strong>模型交付给视图</strong></p>
</li>
<li><p><strong>视图将模型数据渲染输出</strong>，把输出通过响应对象<strong>传递给客户端</strong>。</p>
</li>
</ol>
<h2 id="AtomicInteger为什么要用CAS而不是synchronized？"><a href="#AtomicInteger为什么要用CAS而不是synchronized？" class="headerlink" title="AtomicInteger为什么要用CAS而不是synchronized？"></a>AtomicInteger为什么要用CAS而不是synchronized？</h2><p>CAS是一种<strong>乐观锁，依赖于处理器的底层实现原语</strong>保证CAS的原子性。</p>
<p><strong>使用场景</strong>：线程对于共享资源的竞争不激烈,使用共享资源的时间非常短,不适合Synchronized.因为Synchronized会<strong>频繁的切换上下文</strong>让执行的线程<strong>被阻塞并被挂起</strong>,而<u><strong>这种操作消耗的时间远大于共享资源使用的时间</strong></u>的时候就应该使用<strong>CAS</strong></p>
<p><strong>CAS只适合于线程冲突较少的情况使用</strong></p>
<p><strong>CAS缺点</strong></p>
<ul>
<li><p><strong>ABA问题</strong>： 解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A</p>
</li>
<li><p><strong>若循环时间长，开销大</strong>： 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销</p>
</li>
<li><p><strong>只能保证一个共享变量</strong>的原子操作</p>
</li>
</ul>
<h2 id="查询中哪些情况不会使用索引"><a href="#查询中哪些情况不会使用索引" class="headerlink" title="查询中哪些情况不会使用索引"></a>查询中哪些情况不会使用索引</h2><ol>
<li><p>如果查询条件用or，<strong>必须or条件中的每个列都加上索引</strong>，否则无效。</p>
</li>
<li><p>对于<strong>复合索引</strong>（又叫多列索引或者联合索引），如果<strong>查询的列不使用复合索引的第一部分</strong>，则不使用索引。例如，tb表的复合索引为（key1，key2，key3），则查询select * from tb where key2=1 and key2&gt;5将不会使用索引。</p>
</li>
<li><p>如果<strong>like是以%开头的</strong>，则<strong>该列上的索引不会被使用</strong>。例如：select * from tb where key1 like “%a”; 即使key1列上建立了索引，该查询也不会使用索引。</p>
</li>
<li><p>存在<strong>索引列的数据类型隐形转换</strong>，则不使用索引。例如：列key1的数据类型为字符串，select * from tb where key1=1; 将不会使用索引。要想使用索引，必须将字符串用引号印起来。</p>
</li>
<li><p><strong>where字句里对索引列有数学运算或者使用函数</strong>，则不使用索引。</p>
</li>
</ol>
<h2 id="数据库索引底层为什么要用B树索引"><a href="#数据库索引底层为什么要用B树索引" class="headerlink" title="数据库索引底层为什么要用B树索引"></a>数据库索引底层为什么要用B树索引</h2><img src="/assets/截屏2020-03-2922.51.01.png" style="zoom:50%;" />

<p><strong>B+树特点：</strong></p>
<ul>
<li><p>非叶子结点，关键字数=子树指针树</p>
</li>
<li><p>非叶子结点不含实际数据指针或实际数据，所有关键字都在叶子结点</p>
</li>
<li><p>所有叶子结点增加了一个链指针。遍历整棵树只要遍历所有叶子结点即可</p>
</li>
</ul>
<p><strong>为什么更适合数据库</strong>：</p>
<ul>
<li><p><strong>磁盘读写代价更低：</strong>内部节点没有指向关键字的指针，<strong>内部节点比B树更小</strong>，盘块所能<strong>容纳的关键字多</strong>，<strong>一次性读入内存的关键字也就越多</strong>，相对<strong>IO读写次数就降低</strong>了。</p>
</li>
<li><p><strong>查询效率更加稳定：</strong> 所有关键字查询的路径长度相同，<strong>每一个数据的查询效率相当</strong></p>
</li>
<li><p><strong>方便扫库：</strong> 只需要遍历一遍叶子结点</p>
</li>
</ul>
<h2 id="Mysql主从同步的实现原理？"><a href="#Mysql主从同步的实现原理？" class="headerlink" title="Mysql主从同步的实现原理？"></a>Mysql主从同步的实现原理？</h2><p><strong>主从同步：</strong> 当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。</p>
<p>在master机器上，<strong>主从同步事件</strong>会被写到特殊的log文件中(<strong>binary-log</strong>);</p>
<p>主从同步事件有3种形式:<strong>statement、row、mixed</strong>。</p>
<ul>
<li><p>statement：会将对数据库操作的<strong>sql语句写入到binlog中</strong>。</p>
</li>
<li><p>row：会将<strong>每一条数据的变化写入到binlog中</strong>。</p>
</li>
<li><p>mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。</p>
</li>
</ul>
<p><strong>主从同步：</strong></p>
<ol>
<li><p>当master上的数据发生改变的时候，该<strong>事件(insert、update、delete)变化会按照顺序写入到binlog中</strong>。</p>
</li>
<li><p>当slave连接到master的时候，master机器会<strong>为slave开启<u>binlog dump</u></strong>线程。当master 的 <strong>binlog发生变化</strong>的时候，binlog dump线程会通知slave，并<strong>将binlog发送给slave</strong>。</p>
</li>
<li><p>slave的<u><strong>I/O线程</strong></u>接收到binlog后，再将内容<strong>写入到本地的relay log</strong>。</p>
</li>
<li><p>slave的<u><strong>SQL线程</u>读取relay log</strong>，<strong>更新数据库</strong>。</p>
</li>
</ol>
<p><img src="evernotecid://A2DE6E87-E390-4B1F-98E0-0FD7C58E6B54/appyinxiangcom/28827357/ENResource/p12" alt="d1150d18012395e3be0c03b5960e61de.png"></p>
<h2 id="谈谈数据库乐观锁与悲观锁？"><a href="#谈谈数据库乐观锁与悲观锁？" class="headerlink" title="谈谈数据库乐观锁与悲观锁？"></a>谈谈数据库乐观锁与悲观锁？</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设最坏的情况，<strong>每次去拿数据的时候都认为别人会修改</strong>，所以每次拿数据的时候都会<strong>上锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如<strong>行锁，表锁等，读锁，写锁</strong>等，都是在做<strong>操作之前先上锁</strong>。Java中<strong>synchronized和ReentrantLock等独占锁</strong>就是悲观锁思想的实现。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，<strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h2 id="MongoDB和Redis适用哪些场景"><a href="#MongoDB和Redis适用哪些场景" class="headerlink" title="MongoDB和Redis适用哪些场景"></a>MongoDB和Redis适用哪些场景</h2><p><strong>Redis</strong>：适用于对<strong>读写效率</strong>要求高，<strong>数据处理业务</strong>复杂和对<strong>安全性</strong>要求高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</p>
<p><strong>MongoDB</strong>:主要解决<strong>海量数据的访问效率</strong>问题。</p>
<h2 id="Hbase与传统数据库的区别？与Hive呢？"><a href="#Hbase与传统数据库的区别？与Hive呢？" class="headerlink" title="Hbase与传统数据库的区别？与Hive呢？"></a>Hbase与传统数据库的区别？与Hive呢？</h2><h5 id="与传统数据库的区别："><a href="#与传统数据库的区别：" class="headerlink" title="与传统数据库的区别："></a><strong>与传统数据库的区别：</strong></h5><p>1.<strong>数据类型</strong>：Hbase只有简单的数据类型，只保留<strong>字符串</strong>；传统数据库有<strong>丰富的数据类型</strong>。</p>
<p>2.<strong>数据操作</strong>：Hbase只有简单的<strong>插入、查询、删除、清空</strong>等操作，表和表之间是分离的，没有复杂的表和表之间的关系；传统数据库通常<strong>有各式各样的函数和连接操作</strong>。</p>
<p>3.<strong>存储模式</strong>：Hbase是基于列存储的，每个列族都由几个文件保存，不同列族的文件是分离的，这样的好处是数据即是索引，访问查询涉及的列大量降低系统的I/O，并且每一列由一个线索来处理，可以实现查询的并发处理；传统数据库是基于表格结构和行存储，其没有建立索引将耗费大量的I/O并且建立索引和物化试图需要耗费大量的时间和资源。</p>
<p>4.<strong>数据维护</strong>：Hbase的更新实际上是<strong>插入了新的数据</strong>；传统数据库只是替换和修改。</p>
<p>5.<strong>可伸缩性</strong>：Hbase可以轻松的增加或减少硬件的数目，并且对错误的兼容性比较高；传统数据库需要增加中间层才能实现这样的功能。</p>
<p>6.<strong>事务</strong>：Hbase只可以实现<strong>单行事务性</strong>，意味着行与行之间、表与表之前不必满足事务性；传统数据库是可以实现跨行的事务性。</p>
<h5 id="列式存储的好处"><a href="#列式存储的好处" class="headerlink" title="列式存储的好处"></a>列式存储的好处</h5><p>更适合OLAP的业务 联机分析处理（Online Analytical Processing）</p>
<h5 id="Hbase与Hive"><a href="#Hbase与Hive" class="headerlink" title="Hbase与Hive"></a>Hbase与Hive</h5><ul>
<li><p><strong>Hive适合分析时间段数据,不适合实时数据查询</strong>。Hbase适合实时数据查询</p>
</li>
<li><p>HBase 本身只提供了Java的API接口，并<strong>不直接支持SQL</strong>的语句查询，<strong>Hive支持Hql</strong></p>
</li>
<li><p>默认存储层都是 HDFS。但是<strong>HBase也可以直接使用本机的文件系统</strong>。</p>
</li>
</ul>
<p>Redis和memcache有什么区别？Redis为什么比memcache有优势？</p>
<p>考虑redis的时候，有没有考虑容量？大概数据量会有多少？</p>
<p>谈谈分布式锁、以及分布式全局唯一ID的实现比较？</p>
<p>虚函数的调用</p>
<h2 id="TCP的传输可靠性"><a href="#TCP的传输可靠性" class="headerlink" title="TCP的传输可靠性"></a>TCP的传输可靠性</h2><ul>
<li><p><strong>数据包校验</strong>：检测数据<strong>是否被篡改</strong>，若有错，则<strong>丢弃</strong>报文段并且<strong>不给出响应</strong>，这时TCP发送数据端超时后会<strong>重发</strong>数据；</p>
</li>
<li><p><strong>丢弃重复数据</strong></p>
</li>
<li><p>失序的数据包<strong>重排列</strong></p>
</li>
<li><p><strong>超时重传</strong></p>
</li>
<li><p><strong>流量控制</strong>： <strong>滑动窗口协议</strong>。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出。</p>
</li>
<li><p><strong>ACK机制</strong></p>
</li>
</ul>
<h2 id="客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？"><a href="#客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？"></a>客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h2><p>答：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>
<h5 id="1-DDos-攻击："><a href="#1-DDos-攻击：" class="headerlink" title="(1). DDos 攻击："></a>(1). DDos 攻击：</h5><ol>
<li><p>客户端向服务端发送请求链接数据包</p>
</li>
<li><p>服务端向客户端发送确认数据包</p>
</li>
<li><p>客户端不向服务端发送确认数据包，<strong>服务器一直等待来自客户端的确认</strong></p>
</li>
</ol>
<h5 id="2-DDos-预防：（没有彻底根治的办法，除非不使用TCP）"><a href="#2-DDos-预防：（没有彻底根治的办法，除非不使用TCP）" class="headerlink" title="(2). DDos 预防：（没有彻底根治的办法，除非不使用TCP）"></a>(2). DDos 预防：（没有彻底根治的办法，除非不使用TCP）</h5><ul>
<li><p><strong>限制同时打开SYN半链接的数目</strong></p>
</li>
<li><p>缩短SYN半链接的<strong>Time out 时间</strong></p>
</li>
</ul>
<h2 id="GET-与-POST-的区别"><a href="#GET-与-POST-的区别" class="headerlink" title="GET 与 POST 的区别"></a>GET 与 POST 的区别</h2><p>答：GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：</p>
<ul>
<li><p>从<strong>功能上</strong>讲，GET一般用来从服务器上<strong>获取</strong>资源，POST一般用来<strong>更新</strong>服务器上的资源；</p>
</li>
<li><p><strong>改变资源</strong>：GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</p>
</li>
<li><p><strong>请求参数形式上</strong>看，GET请求的数据会附在URL之后，在HTTP报文的<strong>请求头</strong>中，以?分割URL和传输数据，参数之间以&amp;相连。而POST请求会把提交的数据则放置在是HTTP请求报文的<strong>请求体</strong>中。</p>
</li>
<li><p>就<strong>安全性</strong>而言，<strong>POST的安全性高</strong>，因为GET请求提交的数据将<strong>明文出现在URL上</strong>，而且POST请求参数则被<strong>包装到请求体</strong>中，相对更安全。</p>
</li>
<li><p>从<strong>请求的大小</strong>看，GET请求的长度受限于浏览器或服务器对<strong>URL长度的限制</strong>，允许发送的数据量比较小，而POST请求则是<strong>没有大小限制</strong>的。</p>
</li>
</ul>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>答：TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p>
<ul>
<li><p>TCP是<strong>面向连接</strong>的，UDP是无连接的；</p>
</li>
<li><p>TCP是<strong>可靠</strong>的，UDP是不可靠的；</p>
</li>
<li><p>TCP只支持<strong>点对点</strong>通信，UDP支持<strong>一对一、一对多、多对一、多对多</strong>的通信模式；</p>
</li>
<li><p>TCP是<strong>面向字节流</strong>的，UDP是<strong>面向报文</strong>的；</p>
</li>
<li><p>TCP有<strong>拥塞控制</strong>机制;UDP没有拥塞控制，适合媒体通信；</p>
</li>
<li><p>TCP<strong>首部开销</strong>(20个字节)比UDP的首部开销(8个字节)要大；</p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>TCP</li>
</ul>
<p>当数据传输的性能必须让位于<strong>数据传输的完整性、可控制性和可靠性</strong>时，TCP协议是当然的选择。</p>
<ul>
<li>UDP</li>
</ul>
<p>当<strong>强调传输性能</strong>而不是传输的完整性时，如：音频和多 媒体应用，UDP是最好的选择。在<strong>数据传输时间很短</strong>，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择。</p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><img src="/assets/截屏2020-03-3016.12.13.png" alt="feb445228c98356957596c8753d4bea8" style="zoom:50%;" />

<p><strong>SNMP</strong>：<strong>简单网络管理协议</strong>，使用<strong>161</strong>号端口，是用来<strong>管理网络设备</strong>的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<h2 id="浏览器打开网页过程"><a href="#浏览器打开网页过程" class="headerlink" title="浏览器打开网页过程"></a>浏览器打开网页过程</h2><p><strong>DNS缓存</strong>： 浏览器缓存 -&gt; 系统缓存 -&gt; host文件 -&gt; 路由器缓存 -&gt; 递归搜索根域名服务器</p>
<h2 id="什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h2><p>答：HTTP 是一个无状态的协议，这意味着<strong>每一次的请求都是独立的</strong>，缺少状态意味着<strong>如果后续处理需要前面的信息，则它必须要重传</strong>，这样可能导致每次连接传送的<strong>数据量增大</strong>。另一方面，在服务器不需要先前信息时它的<strong>应答就很快</strong>。</p>
<p>HTTP 的这种特性有优点也有缺点：</p>
<ul>
<li><p><strong>优点</strong>：<strong>解放了服务器</strong>，每一次的请求“点到为止”，<strong>不会造成不必要的连接占用</strong></p>
</li>
<li><p><strong>缺点</strong>：每次请求会<strong>传输大量重复的内容信息</strong>，并且，在<strong>请求之间无法实现数据的共享</strong></p>
</li>
</ul>
<p>解决方案：</p>
<p>使用<strong>参数传递机制解决共享的问题</strong>：</p>
<p>将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：/param/list?username=wmyskxz</p>
<p>问题：<strong>一不安全，二数据允许传输量只有1kb</strong></p>
<p>办法：</p>
<ul>
<li>使用 <strong>Cookie</strong> 技术，<u>客户端保存状态</u></li>
</ul>
<p>Cookie 是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后<strong>向同一服务器再次发起请求时被携带上</strong>，用于告知服务端两个请求<strong>是否来自同一浏览器</strong>。会带来<strong>额外的性能开销</strong>（尤其是在移动环境下）</p>
<ul>
<li>使用 <strong>Session</strong> 技术，<u>服务端保存状态</u></li>
</ul>
<p>如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就<strong>按照sessionid把这个session检索出来</strong>使用；如果客户端请求<strong>不包含sessionid</strong>，则为此客户端<strong>创建</strong>一个session并且生成一个与此session相关联的sessionid，并将这个<strong>sessionid在本次响应中返回给客户端</strong>保存。可以采用<strong>cookie机制保存这个sessionid</strong></p>
<h2 id="Session-与-Cookie-的对比："><a href="#Session-与-Cookie-的对比：" class="headerlink" title="Session 与 Cookie 的对比："></a>Session 与 Cookie 的对比：</h2><ul>
<li><p><strong>实现机制</strong>：<strong>Session常常依赖于Cookie机制</strong>，通过Cookie机制<strong>回传SessionID</strong>；</p>
</li>
<li><p><strong>大小限制</strong>：Cookie有<strong>大小限制</strong>并且浏览器对每个站点也有<strong>cookie的个数限制</strong>，Session没有大小限制，理论上<strong>只与服务器的内存大小有关</strong>；</p>
</li>
<li><p><strong>安全性</strong>：Cookie存在安全隐患，通过<strong>拦截或本地文件</strong>找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
</li>
<li><p><strong>服务器资源消耗</strong>：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
</li>
</ul>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>答：SQL注入就是通过把<strong>SQL命令插入到Web表单提交、输入域名、页面请求的查询字符串</strong>，最终达到<strong>欺骗服务器</strong>执行恶意的SQL命令。</p>
<p>免帐号登录：</p>
<p>用户名：‘or 1 = 1 –</p>
<p>密 码：</p>
<p>SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="容易引起内存泄漏的原因"><a href="#容易引起内存泄漏的原因" class="headerlink" title="容易引起内存泄漏的原因"></a>容易引起内存泄漏的原因</h3><h5 id="静态集合类"><a href="#静态集合类" class="headerlink" title="静态集合类"></a>静态集合类</h5><p>静态集合类的使用最容易引起内存泄漏，因为这些静态变量的生命周期与应用程序一致，它将一直存在，而其中所有的对象也不能被释放。</p>
<h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><p>释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
<h5 id="各种连接"><a href="#各种连接" class="headerlink" title="各种连接"></a>各种连接</h5><p>比如数据库连接和网络连接，除非其显式的关闭了连接，否则是不会自动被GC回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。</p>
<p>如果使用连接池，情况就不一样了，除了要显式地关闭Connection ，还必须显式地关闭Resultset 和Statement 对象（关闭其中一个，另外一个也会关闭）</p>
<h5 id="内部类和外部模块等的引用"><a href="#内部类和外部模块等的引用" class="headerlink" title="内部类和外部模块等的引用"></a>内部类和外部模块等的引用</h5><p>内部类一旦没释放可能导致一系列的后继类对象没有释放。对于程序员而言，自己的程序很清楚，如果发现内存泄漏，自己对这些对象的引用可以很快定位并解决，但是现在的应用软件并非一个人实现，模块化的思想在现代软件中非常明显，所以程序员要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：</p>
<p>public void registerMsg(Object b);</p>
<p>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>　　不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</p>
<h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><ul>
<li><p>尽早释放无用对象的引用</p>
</li>
<li><p>字符串处理时，尽量避免使用String，而应该使用StringBuffer</p>
</li>
<li><p>尽量少用静态变量</p>
</li>
</ul>
<p>因为静态变量是全局的，存在方法区，用永久代实现的方法区，垃圾回收行为在这个区域是比较少出现的，垃圾回收器的主要目标是<strong>针对常量池和类型的卸载</strong>。</p>
<h2 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h2><h5 id="红黑树的各种操作的时间复杂度？"><a href="#红黑树的各种操作的时间复杂度？" class="headerlink" title="红黑树的各种操作的时间复杂度？"></a>红黑树的各种操作的时间复杂度？</h5><p><strong>能保证在最坏情况下，查找、插入和删除的时间均为O（lgn）</strong></p>
<p><strong>AVL PK RBT</strong></p>
<h2 id="classloader加载机制，是否可以自己定义一个java-lang-String类，为什么？"><a href="#classloader加载机制，是否可以自己定义一个java-lang-String类，为什么？" class="headerlink" title="classloader加载机制，是否可以自己定义一个java.lang.String类，为什么？"></a>classloader加载机制，是否可以自己定义一个java.lang.String类，为什么？</h2><h3 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h3><ul>
<li><strong>启动（Bootstrap）类加载器</strong></li>
</ul>
<p>将JAVA_HOME/lib下面的核心类库加载到内存</p>
<ul>
<li><strong>扩展（extand）类加载器</strong></li>
</ul>
<p>负责将JAVA_HOME /lib/ext中的类库加载到内存，开发者可以直接使用</p>
<ul>
<li><strong>系统（System）类加载器</strong></li>
</ul>
<p>用户类路径(java -classpath所指的目录）下的类库加载到内存中，开发者可以直接使用</p>
<h5 id="只有被同一个类加载器实例加载并且文件名相同的class文件才被认为是同一个class-任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性"><a href="#只有被同一个类加载器实例加载并且文件名相同的class文件才被认为是同一个class-任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性" class="headerlink" title="只有被同一个类加载器实例加载并且文件名相同的class文件才被认为是同一个class. 任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性"></a><strong>只有被同一个类加载器实例加载并且文件名相同的class文件才被认为是同一个class.</strong> 任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性</h5><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><img src="/assets/截屏2020-03-3020.20.07.png" alt="8f01068bb734c37ebcbac380417ccbec" style="zoom:50%;" />

<p>父子关系一般通过<strong>组合（Composition）关系</strong>来实现，而不是通过继承（Inheritance）。</p>
<p>类加载器在接到加载类的请求时，首<strong>先将加载任务委托给父类加载器</strong>，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有<strong>父类加载器无法完成</strong>此加载任务时，才<strong>自己去加载</strong></p>
<p><strong>好处</strong>在于<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。例如类<strong>java.lang.Object，它存在在rt.jar中</strong>，无论哪一个类加载器要加载这个类，<strong>最终都是委派给Bootstrap ClassLoader</strong>进行加载，因此Object类在程序的各种类加载器环境中<strong>都是同一个类</strong>。</p>
<p><strong>为什么用双亲委派机制:</strong> </p>
<ul>
<li><p><strong>避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次</strong>。</p>
</li>
<li><p><strong>避免安全隐患</strong>，如果不使用这种委托模式，就可以随时使用自定义的String来动态替代java核心api中定义类型，会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为<strong>String已经在启动时被加载，所以用户自定义类是无法加载的。</strong></p>
</li>
</ul>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想<strong>加载其它位置的类或jar时</strong>，比如：我要加载<strong>网络上的一个class文件</strong>，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p>
<p>定义自已的类加载器分为两步：</p>
<p><strong>1、继承java.lang.ClassLoader</strong></p>
<p><strong>2、重写findClass方法</strong></p>
<h2 id="哪几种创建线程类的方法"><a href="#哪几种创建线程类的方法" class="headerlink" title="哪几种创建线程类的方法"></a>哪几种创建线程类的方法</h2><ul>
<li><p>继承Thread</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>通过Callable和FutureTack创建</p>
</li>
<li><p>创建实现Callable接口的类A</p>
</li>
<li><p>用FutureTask包装A对象</p>
</li>
<li><p>将FutureTask对象作为target创建线程</p>
</li>
</ul>
<h2 id="简述一下List、Set、Map的区别"><a href="#简述一下List、Set、Map的区别" class="headerlink" title="简述一下List、Set、Map的区别"></a>简述一下List、Set、Map的区别</h2><p><strong>List：</strong></p>
<ol>
<li><p>可以允许<strong>重复</strong>的对象。</p>
</li>
<li><p>可以插入多个<strong>null</strong>元素。</p>
</li>
<li><p>是一个有序容器，保持了每个元素的插入<strong>顺序</strong>，输出的顺序就是插入的顺序。</p>
</li>
<li><p>常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p>
</li>
</ol>
<p><strong>Set：</strong></p>
<ol>
<li><p>不允许重复对象</p>
</li>
<li><p>无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。</p>
</li>
<li><p>只允许一个 null 元素</p>
</li>
<li><p>Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</p>
</li>
</ol>
<p><strong>Map</strong></p>
<ol>
<li><p>Map不是collection的子接口或者实现类。Map是一个接口。</p>
</li>
<li><p>Map存储Key Value，Map 可能会持有相同的值对象但键对象必须是唯一的。</p>
</li>
<li><p><strong>TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序</strong>。</p>
</li>
<li><p>Map 里你可以拥有<strong>随意个null值</strong>但最多<strong>只能有一个null键</strong>。</p>
</li>
<li><p>Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p>
</li>
</ol>
<h2 id="说出ArrayList-Vector-LinkedList的存储性能和特性"><a href="#说出ArrayList-Vector-LinkedList的存储性能和特性" class="headerlink" title="说出ArrayList,Vector, LinkedList的存储性能和特性"></a>说出ArrayList,Vector, LinkedList的存储性能和特性</h2><p><strong>ArrayList 和Vector</strong>都是使用<strong>数组</strong>方式存储数据，允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以<strong>索引数据快而插入数据慢</strong>。</p>
<p>Vector中的方法由于添加了synchronized修饰，线程安全，但性能上较ArrayList差，因此已经是Java中的遗留容器。</p>
<p><strong>LinkedList</strong>使用<strong>双向链表</strong>实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，<strong>内存的利用率</strong>更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以<strong>插入速度较快</strong>。</p>
<h2 id="对象序列化机制-Java-的序列化做什么用的-序列化id会出现哪些问题？"><a href="#对象序列化机制-Java-的序列化做什么用的-序列化id会出现哪些问题？" class="headerlink" title="对象序列化机制 Java 的序列化做什么用的 序列化id会出现哪些问题？"></a>对象序列化机制 Java 的序列化做什么用的 序列化id会出现哪些问题？</h2><p><strong>序列化</strong>是指<strong>对象通过写出描述自己状态的数值来记录自己</strong>的过程，即<strong>将对象表示成一系列有序字节，</strong></p>
<p>Java提供了<strong>将对象写入流和从流中恢复对象</strong>的方法。对象能包含其它的对象，而其它的对象又可以包含另外的对象。</p>
<p>Java序列化能够自动的处理嵌套的对象。对于一个对象的<strong>简单域，writeObject()直接将其值写入流中</strong>。当遇到一个<strong>对象域时，writeObject()被再次调用</strong>，如果这个对象内嵌另一个对象，那么，writeObject()又被调用，直到对象能被直接写入流为止。程序员所需要做的是<strong>将对象传入ObjectOutputStream的writeObject()方法</strong>剩下的将有系统自动完成。</p>
<h3 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h3><p><strong>分布式环境</strong>中经常需要<strong>将Object从这一端网络或设备传递到另一端</strong>。这就需要有<strong>一种可以在两端传输数据的协议</strong>。Java序列化机制就是为了解决这个问题而产生</p>
<h3 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h3><p>java的序列化机制是通过在运行时<strong>判断类的serialVersionUID来验证版本一致性</strong>的。在进行<strong>反序列化</strong>时，JVM会把传来的<strong>字节流中的serialVersionUID与本地实体类中的serialVersionUID</strong>进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报<strong>序列化版本不一致的异常</strong>。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>没有显示定义序列化ID，反序列化失败</strong>。Java序列化机制会<strong>根据编译时的class自动生成一个serialVersionUID</strong>作为序列化版本，只有<strong>同一次编译生成的class才会生成相同的serialVersionUID</strong>。一段时间后，本地类中<strong>添加字段</strong>以后，再反序列化时便会出现<strong>serialVersionUID不一致</strong>，导致反序列化失败。</p>
<p><strong>办法</strong>：<strong>显示定义序列化ID</strong></p>
<h2 id="hibernate和mibatis区别？"><a href="#hibernate和mibatis区别？" class="headerlink" title="hibernate和mibatis区别？"></a>hibernate和mibatis区别？</h2><ul>
<li><p>hibernate是全自动，而mybatis是半自动</p>
<p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有<strong>完整的JavaBean对象与数据库的映射结构来自动生成sql</strong>。而<strong>mybatis仅有基本的字段映射</strong>，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p>
</li>
<li><p>hibernate数据库移植性远大于mybatis</p>
<p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此<strong>与数据库的耦合性直接取决于程序员写sql的方法</strong>，如果sql不具通用性而<strong>用了很多某数据库特性</strong>的sql语句的话，<strong>移植性降低</strong>很多，成本很高。</p>
</li>
<li><p>hibernate拥有完整的日志系统，mybatis则欠缺一些</p>
<p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、<strong>关系异常</strong>、<strong>优化警告</strong>、缓存提示、<strong>脏数据警告</strong>等；而mybatis则除了<strong>基本记录功能</strong>外，功能薄弱很多。</p>
</li>
<li><p>mybatis相比hibernate需要关心很多细节</p>
<p>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。<strong>mybatis开发模式上与传统jdbc区别很小，因此很容易上手</strong>并开发项目，需要<strong>关心很多技术细节</strong>，忽略细节会导致项目前期bug较多，因而<strong>开发出相对稳定的软件很慢，而开发出软件却很快</strong>。</p>
<p>hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p>
</li>
<li><p>sql直接优化上，mybatis要比hibernate方便很多</p>
<p>由于<strong>mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多</strong>。而<strong>hibernate的sql很多都是自动生成的，无法直接维护sql</strong>；总之写sql的灵活度上hibernate不及mybatis。</p>
</li>
</ul>
<h2 id="HashMap-、Hashtable和-HashSet的区别？哪个key可以为空？HashMap的内部实现机制，Hash是怎样实现的，什么时候ReHash"><a href="#HashMap-、Hashtable和-HashSet的区别？哪个key可以为空？HashMap的内部实现机制，Hash是怎样实现的，什么时候ReHash" class="headerlink" title="HashMap 、Hashtable和 HashSet的区别？哪个key可以为空？HashMap的内部实现机制，Hash是怎样实现的，什么时候ReHash"></a>HashMap 、Hashtable和 HashSet的区别？哪个key可以为空？HashMap的内部实现机制，Hash是怎样实现的，什么时候ReHash</h2><h3 id="HashTable-和-HashMap"><a href="#HashTable-和-HashMap" class="headerlink" title="HashTable 和 HashMap"></a>HashTable 和 HashMap</h3><p><strong>区别一：继承的父类不同</strong></p>
<p><strong>Hashtable</strong>继承自<strong>Dictionary</strong>类，而<strong>HashMap继承自AbstractMap</strong>类。但二者都实现了Map接口</p>
<p><strong>区别二：线程安全性不同</strong></p>
<p>Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。</p>
<p><strong>区别三：是否提供contains方法</strong></p>
<p><strong>HashMap没有contains方法，改成containsValue和containsKey</strong>，因为contains方法容易让人引起误解。</p>
<p><strong>Hashtable则保留了这三个方法，其中contains和containsValue功能相同</strong>。</p>
<p><strong>区别四：key和value是否允许null值</strong></p>
<p>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。</p>
<p><strong>Hashtable中，key和value都不允许出现null值</strong></p>
<p>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也<strong>可能该键所对应的值为null</strong>。因此，<strong>在HashMap中不能由get()方法来判断HashMap中是否存在某个键</strong>， 而应该用<strong>containsKey</strong>方法来判断。</p>
<p><strong>区别五：哈希值的计算方法不同</strong>，Hashtable直接使用的是对象的hashCode,而HashMap则是在对象的hashCode的基础上%(length-1)。</p>
<h3 id="HashMap和HashSet"><a href="#HashMap和HashSet" class="headerlink" title="HashMap和HashSet"></a>HashMap和HashSet</h3><p>当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先<strong>确保对象重写equals()和hashCode()方法</strong>，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。</p>
<img src="/assets/截屏2020-03-3021.37.42.png" alt="e5a9531b6089889263271f54d05fd9ab" style="zoom:50%;" />

<h3 id="ReHash"><a href="#ReHash" class="headerlink" title="ReHash"></a>ReHash</h3><p>HashMap的<strong>容量达到threshold时</strong>就需要进行<strong>扩容</strong>，这个时候就要进行<strong>ReHash</strong>操作了.扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看<strong>比原来的hash值新增的那个bit是1还是0</strong>就好了，是0的话索引没变，<strong>是1的话索引变成“原索引+oldCap”</strong></p>
<p>集合加锁？那synchronized与static synchronized 的区别？</p>
<p>HashMap、HashTable、ConCurrentHasgMap的区别以及实现原理？</p>
<h2 id="ConCurrentHasgMap调用get（）方法的时候有锁吗？"><a href="#ConCurrentHasgMap调用get（）方法的时候有锁吗？" class="headerlink" title="ConCurrentHasgMap调用get（）方法的时候有锁吗？"></a>ConCurrentHasgMap调用get（）方法的时候有锁吗？</h2><p>没有。 因为Node结点的value被volatile修饰了，保证了内存可见性。</p>
<h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><p><strong>无状态，C/S模式，无连接</strong></p>
<h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>每进行一次HTTP通信，都要断开一次TCP连接。增加通信量的开销。</p>
<p>为了解决TCP的连接问题，HTTP1.1提出了持久连接的方法。</p>
<p>所谓的持久连接，就是<strong>任意一端只要没有明确提出断开连接，则保持TCP连接状态</strong>。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态</p>
<h2 id="JMM在初始化堆内存时，新生代与老年代的默认比例是多少"><a href="#JMM在初始化堆内存时，新生代与老年代的默认比例是多少" class="headerlink" title="JMM在初始化堆内存时，新生代与老年代的默认比例是多少"></a>JMM在初始化堆内存时，新生代与老年代的默认比例是多少</h2><p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，</p>
<p>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定</p>
<h2 id="Spring中控制反转定义？相比于创建对象的好处？AOP编程的优点？"><a href="#Spring中控制反转定义？相比于创建对象的好处？AOP编程的优点？" class="headerlink" title="Spring中控制反转定义？相比于创建对象的好处？AOP编程的优点？"></a>Spring中控制反转定义？相比于创建对象的好处？AOP编程的优点？</h2><h5 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h5><p><strong>资源不由使用资源的双方管理，而由不使用资源的第三方管理</strong>，这可以带来很多好处。</p>
<ul>
<li><p>第一，资源集中管理，实现<strong>资源的可配置和易管理</strong>。</p>
</li>
<li><p>第二，<strong>降低了使用资源双方的依赖程度</strong>，也就是我们说的耦合度。</p>
</li>
</ul>
<h5 id="AOP好处"><a href="#AOP好处" class="headerlink" title="AOP好处"></a>AOP好处</h5><ul>
<li><p>切面的内容可以复用，</p>
</li>
<li><p>避免使用Proxy、CGLIB生成代理，这方面的工作全部框架去实现，开发者可以专注于切面内容本身</p>
</li>
<li><p>代码与代码之间没有耦合，如果拦截的方法有变化修改配置文件即可</p>
</li>
</ul>
<h2 id="SpringMVC中动态代理的实现机制，源码？"><a href="#SpringMVC中动态代理的实现机制，源码？" class="headerlink" title="SpringMVC中动态代理的实现机制，源码？"></a>SpringMVC中动态代理的实现机制，源码？</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Spring AOP编程两种方式</p>
<ul>
<li><p>方式一：Spring AOP使用纯Java实现，通过代理方式向目标类植入增强代码（编程复杂，不推荐）</p>
</li>
<li><p>方式二：使用AspectJ框架</p>
</li>
</ul>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>Spring AOP是基于动态代理的，分别基于两种动态代理机制： <strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong></p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理，<strong>针对目标对象的接口进行代理</strong>，动态生成接口的实现类 <strong>（必须有接口）</strong>。<strong>代理类是接口的实现类</strong></p>
<p>过程要点</p>
<ol>
<li><p>必须对接口生成代理</p>
</li>
<li><p><strong>采用Proxy对象，通过newProxyInstance方法为目标创建代理对象</strong>。</p>
</li>
</ol>
<p>该方法接收<strong>三个参数</strong> ：</p>
<p>（1）<strong>目标对象类加载器</strong></p>
<p>（2）<strong>目标对象实现的接口</strong></p>
<p>（3）代理后的<strong>处理程序InvocationHandler</strong></p>
<ol start="3">
<li><strong>实现InvocationHandler接口中 invoke方法</strong>，在目标对象每个方法调用时，都会执行invoke</li>
</ol>
<h4 id="CGlib代理"><a href="#CGlib代理" class="headerlink" title="CGlib代理"></a>CGlib代理</h4><p>不需要接口也可以代理.运行期间生成的代理对象是针对目标类扩展的子类。<strong>代理类是目标类的子类。</strong></p>
<ol>
<li><p><strong>代理工厂</strong>实现MethodInteceptor接口，实现intercept方法</p>
</li>
<li><p>获取<strong>代理对象生成器Enhancer</strong></p>
</li>
<li><p>给生成器设置<strong>目标类加载器</strong>，设置<strong>目标类</strong>，设置<strong>回调方法</strong>（this.intercept()）</p>
</li>
<li><p>创建代理对象。enhancer.create</p>
</li>
</ol>
<h2 id="怎么实现让两个线程交替执行？（用代码实现？）"><a href="#怎么实现让两个线程交替执行？（用代码实现？）" class="headerlink" title="怎么实现让两个线程交替执行？（用代码实现？）"></a>怎么实现让两个线程交替执行？（用代码实现？）</h2><p>CAS + volatile实现两个线程交替输出奇偶数。用原子类当被增加的数，flag用volatile。</p>
<img src="/assets/截屏2020-04-0123.31.37.png" alt="190a12649aa39310f64694e17fd0478c" style="zoom:50%;" />

<h2 id="使用过哪些写代码的工具？（Myeclipse和IDE），列出你常用的快捷键？"><a href="#使用过哪些写代码的工具？（Myeclipse和IDE），列出你常用的快捷键？" class="headerlink" title="使用过哪些写代码的工具？（Myeclipse和IDE），列出你常用的快捷键？"></a>使用过哪些写代码的工具？（Myeclipse和IDE），列出你常用的快捷键？</h2><p>IDEA</p>
<p>Control + J 快速查看文档</p>
<p>Control + O 覆盖方法（重写父类方法）</p>
<p>Command + Option + T 包围代码（使用if…else、try…catch、for、synchronized等包围选中的代码）</p>
<p>Control + Option + O 优化 import</p>
<p>Control + Option + I 自动缩进线</p>
<p>Command + Option + O 前往指定的变量 / 方法</p>
<p>Command + O 查找类文件</p>
<p>各种容器的初始化长度是多少？</p>
<h2 id="使用ArrayList初始化时注意事项？（自动扩充机制方面，原理实现）？"><a href="#使用ArrayList初始化时注意事项？（自动扩充机制方面，原理实现）？" class="headerlink" title="使用ArrayList初始化时注意事项？（自动扩充机制方面，原理实现）？"></a>使用ArrayList初始化时注意事项？（自动扩充机制方面，原理实现）？</h2><p>创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<p>加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1)，也就是<strong>旧容量的 1.5 倍。</strong></p>
<p>扩容操作需要调用 <strong>Arrays.copyOf() 把原数组整个复制到新数组中</strong>，这个操作代价很高</p>
<p>说一个你最熟悉的设计模式</p>
<p>堆排序的原理</p>
<h2 id="抽象工厂和工厂方法模式的区别"><a href="#抽象工厂和工厂方法模式的区别" class="headerlink" title="抽象工厂和工厂方法模式的区别"></a>抽象工厂和工厂方法模式的区别</h2><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>提供一个接口，用于创建 相关的对象家族 。抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象。</p>
<p>工厂模式的思想</p>
<p>分布式了解么</p>
<p>介绍一下红黑树</p>
<h2 id="消息队列了解么"><a href="#消息队列了解么" class="headerlink" title="消息队列了解么"></a>消息队列了解么</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li><strong>解耦</strong></li>
</ul>
<p><img src="evernotecid://A2DE6E87-E390-4B1F-98E0-0FD7C58E6B54/appyinxiangcom/28827357/ENResource/p44" alt="94afca33c75999f5628e80157ee06e23.png"></p>
<ul>
<li><p><strong>异步</strong>，提高用户体验和吞吐量。A不用等B C D</p>
</li>
<li><p><strong>削峰</strong></p>
</li>
</ul>
<p><img src="evernotecid://A2DE6E87-E390-4B1F-98E0-0FD7C58E6B54/appyinxiangcom/28827357/ENResource/p44" alt="94afca33c75999f5628e80157ee06e23.png"></p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p><strong>确保高可用</strong> 支持分布式实现。单机崩了，整个系统会不可用</p>
</li>
<li><p><strong>数据丢失</strong> B C没来得及na数据</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/assets/Avatar.jpeg"
                alt="叶子" />
            
              <p class="site-author-name" itemprop="name">叶子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yesunch" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="sun.ye@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">叶子</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
