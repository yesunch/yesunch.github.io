<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>叶子冲冲冲</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/profile.png)">
        </div>
    </section>
    <section class='menu'>
        <div>叶子冲冲冲</div>
        
            <div>相信你，你可以的</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ redis }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/05/30/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">redis笔记</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-05-30T09:48:11.000Z" itemprop="datePublished">
    2020-05-30
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/redis/">redis</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>字符串对象是五个基本对象中唯一会被其他对象嵌套的对象</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><h4 id="embstr-embstr编码的SDS"><a href="#embstr-embstr编码的SDS" class="headerlink" title="embstr(embstr编码的SDS)"></a>embstr(embstr编码的SDS)</h4><p>条件：<strong>短字符串</strong>(&lt;= 32字节)。</p>
<p>raw会调用两次内存分配函数来创建redisObject和sdshdr,embstr只会调用一次分配一块连续地址空间，来保存redisObject和sdshdr</p>
<h4 id="raw-SDS"><a href="#raw-SDS" class="headerlink" title="raw(SDS)"></a>raw(SDS)</h4><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p><strong>条件</strong>：元素长度&lt;64字节，元素个数&lt;512.</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>链表里包含了多个字符串对象，里面嵌套着字符串</p>
<h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><h4 id="ziplist-1"><a href="#ziplist-1" class="headerlink" title="ziplist"></a>ziplist</h4><p><strong>条件</strong>：键和值长度都&lt;64字节，键值对个数&lt;512.</p>
<ul>
<li>键结点和值结点紧挨在一起</li>
</ul>
<h4 id="HT-字典-（hashtable）"><a href="#HT-字典-（hashtable）" class="headerlink" title="HT 字典 （hashtable）"></a>HT 字典 （hashtable）</h4><ul>
<li>每个键值对用一个字典键值对存储</li>
</ul>
<p><img src="evernotecid://A2DE6E87-E390-4B1F-98E0-0FD7C58E6B54/appyinxiangcom/28827357/ENResource/p134" alt="8fd8ee312439309d448e60594e9c88e0.png"></p>
<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><h4 id="INTSET整数集合"><a href="#INTSET整数集合" class="headerlink" title="INTSET整数集合"></a>INTSET整数集合</h4><p><strong>条件</strong>：都是整数，个数&lt;512</p>
<h4 id="HT-字典"><a href="#HT-字典" class="headerlink" title="HT 字典"></a>HT 字典</h4><h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><p>为什么<strong>同时使用字典和跳跃表</strong>：</p>
<ul>
<li><p>保留字典的<strong>O(1)查找</strong>特性</p>
</li>
<li><p>保留跳跃表执行<strong>范围型操作</strong>的优点</p>
</li>
<li><p>字典跳跃表<strong>共享元素</strong>的成员和分值，不会有内存浪费和数据重复</p>
</li>
</ul>
<h4 id="ziplist-2"><a href="#ziplist-2" class="headerlink" title="ziplist"></a>ziplist</h4><h4 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h4><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>检查<strong>redisObject结构的type属性</strong></p>
<h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><h4 id="基于类型的多态"><a href="#基于类型的多态" class="headerlink" title="基于类型的多态"></a>基于类型的多态</h4><p>DEL, EXPIRE等对所有类型的键都可以正确执行</p>
<h4 id="基于编码的多态"><a href="#基于编码的多态" class="headerlink" title="基于编码的多态"></a>基于编码的多态</h4><p>例子： LLEN对ziplist和linkedlist的list都可以正确执行，根据编码使用不同的API</p>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p><strong>引用计数</strong>-&gt;内存回收机制，对象共享机制</p>
<ul>
<li><p>将键的值指针指向一个现有的值对象</p>
</li>
<li><p>值对象引用计数+1</p>
</li>
</ul>
<p>在redis<strong>初始化</strong>时，会创建一万个字符串对象，<strong>0～9999</strong>，用来共享使用</p>
<h3 id="对象lru时间"><a href="#对象lru时间" class="headerlink" title="对象lru时间"></a>对象lru时间</h3><p>redisObject的lru属性会保存对象最后一次被访问的时间</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><ul>
<li><p><strong>EXPIRE</strong> key ttl 键的生存时间设置为<strong>ttl秒</strong></p>
</li>
<li><p><strong>PEXPIRE</strong> key ttl 生存时间设置为<strong>ttl毫秒</strong></p>
</li>
<li><p><strong>EXPIREAT</strong> key timestamp 过期时间设置为<strong>timestamp指定的秒数时间戳</strong></p>
</li>
<li><p><strong>PEXPIREAT</strong> key timestamp 过期时间设置为<strong>timestamp指定的毫秒数时间戳</strong></p>
</li>
</ul>
<p>EXPIRE, PEXPIRE, EXPIREAT 都是用PEXPIREAT实现的</p>
<h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p><strong>PERSIST</strong> 移除过期时间</p>
<h3 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h3><p>redisDb的<strong>expires字典</strong>保存了所有键的过期时间。</p>
<p>过期字典的<strong>键是指针</strong>，指向对应键。过期字典的<strong>值是long long类型的整数</strong>——毫秒精度的<strong>unix时间戳</strong>。</p>
<p>过期字典的<strong>键指向键空间的键对象</strong>，所以不存在内存浪费</p>
<h3 id="返回剩余生存时间"><a href="#返回剩余生存时间" class="headerlink" title="返回剩余生存时间"></a>返回剩余生存时间</h3><ul>
<li><p>TTL 秒精度</p>
</li>
<li><p>PTTL 毫秒精度</p>
</li>
</ul>
<h2 id="AOF和RDB对过期键的处理"><a href="#AOF和RDB对过期键的处理" class="headerlink" title="AOF和RDB对过期键的处理"></a>AOF和RDB对过期键的处理</h2><h3 id="生成RDB"><a href="#生成RDB" class="headerlink" title="生成RDB"></a>生成RDB</h3><p>SAVE或BFSAVE时，<strong>过期的键不会被保存到RDB文件里</strong></p>
<h3 id="载入RDB"><a href="#载入RDB" class="headerlink" title="载入RDB"></a>载入RDB</h3><p>主服务器不载入过期键。从服务器会载入过期键。但是主从同步时会清空从服务器的数据库</p>
<h3 id="AOF写入"><a href="#AOF写入" class="headerlink" title="AOF写入"></a>AOF写入</h3><p>未删除的过期键不会影响AOF</p>
<p><strong>过期键被删除</strong>之后，向AOF<strong>追加一条DEL记录</strong></p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>过期键不会被保存到新AOF文件</p>
<h3 id="复制模式下"><a href="#复制模式下" class="headerlink" title="复制模式下"></a>复制模式下</h3><p>主服务器删除过期键时，显式向从服务器发DEL命令。</p>
<p>从服务器只在接收到主服务器DEL命令时，才会删除过期键</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul>
<li><p>Redis服务器的<strong>所有数据库</strong>都保存在<strong>redisServer.db</strong>中，数据库数量由redisServer.dbnum属性保存</p>
</li>
<li><p><strong>客户端通过修改目标数据库指针</strong>，让它指向redisServer.db数组中不同元素来切换数据库</p>
</li>
<li><p>数据库由<strong>dict和expire两个字典</strong>构成。expire键指向数据库某个键，值是该键的过期时间</p>
</li>
<li><p>键总是字符串对象，值可以是任意对象类型</p>
</li>
<li><p>Redis使用<strong>惰性删除</strong>和<strong>定期删除</strong>。惰性删除，使用时才删除。定期删除，定期主动查找并删除过期键</p>
</li>
<li><p>当redis命令对数据库修改后，服务器会根据配置向客户端发送通知</p>
</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><h3 id="RDB文件创建"><a href="#RDB文件创建" class="headerlink" title="RDB文件创建"></a>RDB文件创建</h3><ul>
<li><p><strong>SAVE 阻塞</strong>服务器进程，直到RDB文件创建完毕</p>
</li>
<li><p><strong>BGSAVE 派生出子进程</strong>，子进程创建RDB文件，服务器进程继续处理请求</p>
</li>
<li><p>BGSAVE时，会拒绝客户端的SAVE命令。避免父子进程同时调用rdbSave，产生竞态条件</p>
</li>
</ul>
<h3 id="RDB文件载入"><a href="#RDB文件载入" class="headerlink" title="RDB文件载入"></a>RDB文件载入</h3><p>只要Redis服务器<strong>启动时检测到</strong>RDB文件，就会<strong>自动载入</strong>RDB文件</p>
<ul>
<li><p>如果服务器<strong>开启了AOF</strong>持久化，就会<strong>优先使用AOF</strong>来还原数据库</p>
</li>
<li><p>只有AOF关闭时，才会使用RDB来还原数据库</p>
</li>
<li><p><strong>载入RDB</strong>期间，服务器<strong>一直被阻塞</strong></p>
</li>
</ul>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>可以设置服务器配置的save选项，每隔一段时间就自动执行BGSAVE</p>
<p>可以通过<strong>save</strong>选项设置<strong>多个保存条件</strong></p>
<ul>
<li>save 900 1 // 900秒之内，对数据库进行了至少一次更改</li>
<li>save 300 10 //300秒之内，至少10次更改</li>
</ul>
<h3 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h3><p><strong>saveParams数组：</strong> 服务器根据save命令设置对条件，设置redisServer结构的<strong>saveParams</strong>数组，每个元素都是一个saveParam结构。</p>
<img src="/Users/yesun/Desktop/截屏2020-04-1920.23.01.png" style="zoom:50%;" />

<p><strong>dirty计数器</strong>: 距离上一次SAVE/BGSAVE后，服务器对数据库修改了多少次</p>
<p><strong>lastsave属性</strong>： 一个UNIX时间戳，记录服务器上一次SAVE/BGSAVE的时间</p>
<h3 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h3><p>服务器周期性操作函数<strong>serverCron</strong>每100毫秒执行一次，检查save选项的保存条件是否满足。满足，就执行<strong>BGSAVE</strong></p>
<h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>REDIS(5字节)</td>
<td>Db_version（4字节）</td>
<td>databases</td>
<td>EOF（1字节）</td>
<td align="center">Check_sum</td>
</tr>
</tbody></table>
<p>databases部分可以保存任意多个非空数据库</p>
<p>每个database:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECTDB</td>
<td>db_number</td>
<td>key_value_pairs</td>
</tr>
</tbody></table>
<p>每个key value(不带过期时间):</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>TYPE</td>
<td>key</td>
<td align="center">Value</td>
</tr>
</tbody></table>
<p>带过期时间的key value:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>EXPIRETIME_MS</td>
<td>ms(UNIX 时间戳)</td>
<td>TYPE</td>
<td>key</td>
<td>value</td>
</tr>
</tbody></table>
<h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>AOF持久化打开时，写命令会被追加到aof_buf缓冲区末尾</p>
<h3 id="文件写入和同步"><a href="#文件写入和同步" class="headerlink" title="文件写入和同步"></a>文件写入和同步</h3><p>先<strong>写入aof_buf缓冲区</strong>，然后调用<strong>flushAppengOnlyFile</strong>函数，看<strong>是否需要将aof_buf写入AOF文件</strong>。如果<strong>appendfsync</strong>选项的值为everysec,并且距离上次同步AOF文件超过一秒，那么先<strong>将aof_buf中的内容写入AOF文件</strong>，然后<strong>再对AOF文件同步</strong>，强制立刻写入硬盘</p>
<p>appendfsync的值直接决定AOF的效率和安全性：</p>
<ul>
<li><strong>always</strong>: <strong>每个事件循环</strong>都把aof_buf<strong>写入</strong>AOF文件，并<strong>同步</strong>AOF文件。<strong>效率最慢，最安全</strong></li>
<li><strong>everysec</strong>: <strong>每个事件循环</strong>都把aof_buf<strong>写入</strong>AOF文件, <strong>每隔一秒</strong>在子线程中进行<strong>同步</strong>。<strong>够快</strong>，只丢一秒数据</li>
<li><strong>no</strong>:<strong>每个事件循环</strong>都把aof_buf<strong>写入</strong>AOF文件, 由<strong>操作系统决定何时同步</strong>。<strong>写入速度最快，单次同步时间最长</strong>（会积累写入数据）</li>
</ul>
<h3 id="AOF文件载入和数据还原"><a href="#AOF文件载入和数据还原" class="headerlink" title="AOF文件载入和数据还原"></a>AOF文件载入和数据还原</h3><ol>
<li>创建一个不带网络连接的<strong>伪客户端</strong>。Redis的命令只能在客户端上下文执行，而AOF的命令来源于AOF文件。所以由伪客户端执行AOF文件里的命令</li>
<li>从AOF文件拿一条命令</li>
<li>客户端执行。</li>
<li>重复2，3</li>
</ol>
<h3 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>解决<strong>AOF文件过大</strong>的问题。新旧AOF文件保存的数据库状态相同，但新文件没有冗余命令。</p>
<p><strong>原理</strong>： 从数据库中<strong>读取键现在的值</strong>，然后用<strong>一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令。</p>
<p>子进程执行AOF重写，两个目的：</p>
<ul>
<li>不影响<strong>父进程处理客户端请求</strong></li>
<li>子进程有父进程的数据副本，<strong>避免使用锁</strong>，保证数据安全</li>
</ul>
<h4 id="重写过程中数据不一致"><a href="#重写过程中数据不一致" class="headerlink" title="重写过程中数据不一致"></a>重写过程中数据不一致</h4><p><strong>AOF重写缓冲区</strong>，在创建子进程后开始使用。服务器执行完一个命令后，<strong>同时发给AOF缓冲区和AOF重写缓冲区。</strong></p>
<p>子进程完成重写后，给父进程发信号，父进程：</p>
<ul>
<li>将<strong>AOF重写缓冲区写入</strong>新AOF文件</li>
<li>对新AOF文件进行<strong>改名</strong>，原子地<strong>覆盖</strong>旧AOF文件。</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>服务器处理两类事件：</p>
<ul>
<li><strong>文件事件</strong>：服务端 通过套接字与客户端连接。<strong>与客户端的通信</strong>会产生相应的文件事件</li>
<li><strong>时间事件：</strong> 一些<strong>定时操作</strong>。服务器中一些操作需要在给定时间点执行，如serverCron函数。</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p><strong>Reactor模式</strong>下的网络事件处理器（文件事件处理器）</p>
<ul>
<li><strong>IO多路复用</strong>同时监听多个套接字，给套接字<strong>关联不同的事件处理器</strong></li>
<li>当被监听的<strong>套接字准备好</strong>进行<strong>accept（连接应答）, read, write, close</strong>等操作时，会产生相应的文件事件，<strong>文件事件处理器就会调用关联的事件处理器</strong>来处理。</li>
</ul>
<p><strong>文件事件处理器</strong>四个组成部分：</p>
<ul>
<li>套接字</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器</li>
</ul>
<h3 id="IO多路复用程序的实现"><a href="#IO多路复用程序的实现" class="headerlink" title="IO多路复用程序的实现"></a>IO多路复用程序的实现</h3><p>Redis包装了select,epoll, evport, kqueue等IO多路复用函数库，为每个函数库都<strong>实现了相同的API</strong>，所以底层实现是可以互换的，<u>IO多路复用程序有<strong>多个IO多路复用库可选</strong></u></p>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li><p><strong>AE_READABLE</strong></p>
<p>套接字可读时（客户端对套接字write/close）,或者新的acceptable套接字出现时</p>
</li>
<li><p><strong>AE_WRITABLE</strong></p>
<p>套接字可写时（客户端对套接字read）</p>
</li>
</ul>
<p>同时监听这两种事件，文件事件分派器<strong>优先处理AE_READABLE.</strong></p>
<h3 id="不同文件事件处理器"><a href="#不同文件事件处理器" class="headerlink" title="不同文件事件处理器"></a>不同文件事件处理器</h3><ul>
<li><strong>连接应答处理器</strong></li>
<li><strong>命令请求处理器</strong>：接收命令请求。客户端连接整个过程中，都保持关联</li>
<li><strong>命令回复处理器</strong>：返回执行结果。回复发送完毕后，解除关联。</li>
<li><strong>复制处理器</strong>：主从复制</li>
</ul>
<h3 id="完整的客户端与服务端连接事件示例"><a href="#完整的客户端与服务端连接事件示例" class="headerlink" title="完整的客户端与服务端连接事件示例"></a>完整的客户端与服务端连接事件示例</h3><ol>
<li>服务器正在运作，<strong>正在监听AE_READABLE事件</strong>，处理器为连接应答处理器</li>
<li>客户端<strong>发起连接</strong>，<strong>产生AE_REABDABLE事件</strong>，<strong>连接应答处理器</strong>执行，<strong>创建客户端套接字</strong>和客户端状态。将客户端套接字的<strong>AE_READABLE事件与命令请求处理器关联</strong></li>
<li>客户端<strong>发送命令</strong>，产生<strong>AE_READABLE</strong>事件，<strong>命令请求处理器</strong>执行。</li>
<li><strong>产生命令回复</strong>，将套接字<strong>AE_WRITABLE事件</strong>与<strong>命令回复处理器关联</strong>。客户端尝试读取命令回复时，产生AE_WRITABLE事件，命令回复处理器执行，将回复全部<strong>写入</strong>套接字。服务端<strong>解除</strong>客户端套接字的AE_WRITABLE事件和命令回复处理器的关联</li>
</ol>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>两类：</p>
<ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<p>组成：</p>
<ul>
<li><strong>事件id</strong></li>
<li><strong>when</strong>: 毫秒精度UNIX时间戳</li>
<li><strong>timeProc</strong>:时间事件处理函数</li>
</ul>
<p>区别：</p>
<ul>
<li>timeProc返回AE_NOMORE，则为定时事件。到达之后会被删除</li>
<li>timeProc返回非AE_NOMORE的整数值，则为周期性事件。返回30，则该事件在30毫秒后再次到达</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>所有时间事件放在一个<strong>无序链表</strong>(不按when排序）里，时间事件执行器遍历整个链表<strong>，查找已到达的事件，</strong>调用**相应的事件处理器</p>
<p><strong>为什么无序不影响性能</strong></p>
<p>正常模式下的Redis只使用serverCron一个时间事件， benchmark模式下，使用两个时间事件。无序链表<strong>已退化成指针。</strong></p>
<h3 id="serverCron函数职责"><a href="#serverCron函数职责" class="headerlink" title="serverCron函数职责"></a>serverCron函数职责</h3><ul>
<li>更新服务器的各类<strong>统计信息</strong>，时间、内存占用、数据库占用情况等</li>
<li>清理数据库<strong>过期键值对</strong></li>
<li>关闭<strong>清理连接失效客户端</strong></li>
<li>尝试RDB/AOF<strong>持久化</strong></li>
<li>定期<strong>同步从服务器</strong></li>
<li>对集群进行定期同步和连接测试</li>
</ul>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><ul>
<li>等待文件事件产生</li>
<li>处理已产生的文件事件</li>
<li>处理已到达的时间事件</li>
<li>返回1</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>文件事件是随机出现的，随着文件事件不断执行，时间会逐渐向时间事件设置的到达时间逼近</li>
<li>对文件事件和时间事件的处理是<strong>同步、有序、原子</strong>的。<strong>不会中断、抢占</strong>事件处理。因此事件处理器会尽可能减少程序阻塞事件，并必要时主动让出执行权。如命令回复处理器写了很多字节后，会主动跳出循环，留着下次再写。</li>
<li>时间事件的实际处理时间，会比设定时间稍微晚一些</li>
</ol>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>每个客户端在服务区都对应一个redisClient结构，包括：</p>
<ul>
<li>客户端<strong>套接字描述符</strong></li>
<li>客户端<strong>名字</strong></li>
<li>客户端<strong>标志值</strong></li>
<li>客户端<strong>正在使用的数据库指针</strong></li>
<li>客户端<strong>输入缓冲区和输出缓冲区</strong></li>
<li>。。。。</li>
</ul>
<p>服务器状态结构的<strong>clients属性链表</strong>保存了所有连接的客户端状态结构</p>
<h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>fd属性是&gt;=-1的整数</p>
<ul>
<li><strong>伪客户端</strong>的fd属性为<strong>-1</strong>。伪客户端的命令请求来源于AOF文件或Lua脚本，不是网络</li>
<li>普通客户端的fd&gt;-1。</li>
</ul>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><ul>
<li><strong>主从复制时，主会成为从的客户端，从也会成为主的客户端</strong>。REDIS_MASTER表示客户端是一个主服务器，REDIS_SLAVE表示客户端是从服务器</li>
<li>REDIS_BLOCKED 客户端正在被BRPOP, BLPOP等命令阻塞</li>
<li>REDIS_MULTI 客户端正在执行事务</li>
<li>REDIS_DIRTY_CAS 事务使用watch监视的键已经被修改，事务安全性被破坏</li>
</ul>
<h3 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h3><p>服务器的redisClient结构里sds querybuf属性<strong>保存客户端发送的命令</strong>。大小不超过1GB。否则服务器会关闭该客户端</p>
<h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令所得的<strong>命令回复</strong>会保存在客户端状态里的输出缓冲区里。</p>
<p>两个输出缓冲区可用。一个大小固定，一个大小可变。</p>
<ul>
<li>固定大小的缓冲区保存长度较小的回复，比如OK，短字符串，整数等</li>
<li>可变大小缓冲区保存长度比较大的回复。</li>
</ul>
<p>固定大小缓冲区有两个属性，<strong>buf</strong>字节数组, <strong>bufpos</strong>数组已使用的字节数量。</p>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>authenticated属性若为0，服务器拒绝执行AUTH之外的一切命令。AUTH成功验证后，0变1.</p>
<h2 id="客户端的创建和关闭"><a href="#客户端的创建和关闭" class="headerlink" title="客户端的创建和关闭"></a>客户端的创建和关闭</h2><p>服务器用不同的方式创建关闭不同客户端</p>
<h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>客户端使用<strong>connect函数连接</strong>到服务器时，服务器<strong>调用连接事件处理器</strong>，<strong>创建客户端状态</strong>，链接到服务器状态结构<strong>clients链表</strong>末尾</p>
<h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>关闭原因：</p>
<ul>
<li>客户端进程退出，网络连接被关闭，客户端被关闭</li>
<li>客户端发送了不符合协议要求的命令</li>
<li>客户端是CLIENT KILL的目标</li>
<li>客户端空转时间超过timeout设置值（如果被设置的话）</li>
<li>客户端发送命令超过了输入缓冲区大小限制，默认1GB</li>
<li>命令回复超过了输出缓冲区大小限制</li>
</ul>
<p>两种模式<strong>限制输出缓冲区</strong>：</p>
<ul>
<li><strong>硬性限制</strong>：超出，立即关闭</li>
<li><strong>软性限制</strong>：超过软性限制大小，服务器记录客户端超过软性限制的时间，若一直超出且持续时间超过设定值，关闭客户端。</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h2 id="命令请求执行过程"><a href="#命令请求执行过程" class="headerlink" title="命令请求执行过程"></a>命令请求执行过程</h2><ol>
<li>客户端发送SET KEY VALUE</li>
<li>服务器接收命令，设置数据库，产生命令回复OK</li>
<li>服务器发送命令回复</li>
<li>客户端打印命令回复</li>
</ol>
<h3 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h3><p>客户端将命令<strong>转换成协议格式</strong>，通过套接字，发送给服务器</p>
<h3 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h3><p>套接字可读时，服务器调用<strong>命令请求处理器</strong>。</p>
<ol>
<li>读取套接字中协议格式命令请求，<strong>保存到客户端的输入缓冲区</strong></li>
<li>分析命令，<strong>提取命令参数，命令参数个数</strong>，保存到客户端状态的<strong>argv和argc属性</strong></li>
<li><strong>调用命令执行器</strong>，执行命令</li>
</ol>
<h3 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h3><p>命令执行器<strong>根据argv[0]</strong>参数，在<strong>命令表里查找</strong>指定命令，保存在客户端状态<strong>cmd属性</strong>里</p>
<p>命令表是个字典，键是命令名字，值是redisCommand结构，记录了实现信息</p>
<h3 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h3><ul>
<li>检查<strong>cmd指针是否是NULL</strong></li>
<li>检查cmd指向的redisCommand结构的arity属性和参数个数</li>
<li>检查<strong>客户端是否通过身份验证</strong></li>
<li>如果服务器打开了<strong>maxmemory</strong>,先<strong>检查内存占用</strong>情况，必要时进行内存回收</li>
<li>如果服务器<strong>正在执行Lua脚本</strong>并进入阻塞状态，只执行客户端的SHUTDOWN nosave和SCRIPT KILL</li>
</ul>
<h3 id="命令执行器（3）：调用命令实现函数"><a href="#命令执行器（3）：调用命令实现函数" class="headerlink" title="命令执行器（3）：调用命令实现函数"></a>命令执行器（3）：调用命令实现函数</h3><p>Client-&gt;cmd-&gt;proc(client)</p>
<h3 id="命令执行器（4）：执行后续工作"><a href="#命令执行器（4）：执行后续工作" class="headerlink" title="命令执行器（4）：执行后续工作"></a>命令执行器（4）：执行后续工作</h3><ul>
<li><strong>慢查询日志模块</strong>检查是否需要为这条指令添加新的慢查询日志</li>
<li>更新被执行命令的<strong>redisCommand结构的milliseconds</strong>属性，将<strong>calls计数器</strong>加一</li>
<li>若开启AOF持久化，AOF持久化模块将这条命令<strong>写入AOF缓冲区</strong></li>
<li>若有从服务器在复制当前服务器，服务器将命令<strong>传播给所有从服务器</strong></li>
</ul>
<h3 id="命令回复发送给客户端"><a href="#命令回复发送给客户端" class="headerlink" title="命令回复发送给客户端"></a>命令回复发送给客户端</h3><p>命令实现函数将回复<strong>保存在客户端输出缓冲区</strong>，给客户端的套接字<strong>关联命令回复处理器</strong>。套接字<strong>可读时</strong>，执行<strong>命令回复处理器</strong>，将输出缓冲区中的<strong>回复发送给客户端</strong>。</p>
<h3 id="客户端接收并打印"><a href="#客户端接收并打印" class="headerlink" title="客户端接收并打印"></a>客户端接收并打印</h3><p>客户端将回复转换成可读格式，打印</p>
<h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>服务器中的serverCron默认每100毫秒执行一次</p>
<h3 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h3><p>服务器每次获取系统当前时间都要执行系统调用。为了<strong>减少系统调用次数</strong>，服务器状态中<strong>unixtime</strong>属性和<strong>mstime</strong>属性被用作当前时间的缓存，每100毫秒更新一次。</p>
<h3 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h3><p>服务器状态中的<strong>lruclock</strong>属性保存了服务器的LRU时钟。每10秒更新一次</p>
<p><strong>计算数据库键的空转时间</strong>时，服务器的lruclock-对象的lru，就是这个对象的空转时间</p>
<h3 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h3><h3 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h3><h3 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h3><p>检查服务器状态的shutdown_asap属性，<strong>决定是否关闭服务器</strong></p>
<h3 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h3><ul>
<li>若<strong>连接已经超时</strong>，释放客户端</li>
<li><strong>输入缓冲区过大</strong>，释放当前输入缓冲区，重新创建默认大小的输入缓冲区，防止耗费过度内存</li>
</ul>
<h3 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h3><p>服务器执行BGSAVE期间，如果客户端发来BGREWRITEAOF命令，服务器会把BGREWRITEAOF的执行时间延迟到BGSAVE命令执行完毕后</p>
<h3 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h3><p>检查<strong>rdb_child_pid</strong>和<strong>aof_child_pid</strong>, 若<strong>有一个不是-1</strong>，执行wait3函数，检查子进程<strong>是否发来信号</strong>：</p>
<ul>
<li>如果有信号到达，说明新RDB文件生成完毕或AOF文件已经重写完毕，服务器进行后续操作，用新的RDB文件替换旧的，或者用新的AOF文件替换旧的</li>
<li>否则，不做动作</li>
</ul>
<p>如果<strong>两个都是-1</strong>，说明没有在进行持久化操作：</p>
<ul>
<li>是否有 <strong>BGREWRITEAOF被延迟</strong>，若有，开始执行</li>
<li>检查<strong>自动保存条件</strong>，若满足，开始BGSAVE</li>
<li>检查<strong>AOF重写条件</strong>，若满足，开始BGREWRITEAOF</li>
</ul>
<h3 id="将AOF缓冲区内容写入AOF文件"><a href="#将AOF缓冲区内容写入AOF文件" class="headerlink" title="将AOF缓冲区内容写入AOF文件"></a>将AOF缓冲区内容写入AOF文件</h3><h3 id="增加cronloops计数器"><a href="#增加cronloops计数器" class="headerlink" title="增加cronloops计数器"></a>增加cronloops计数器</h3><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>创建struct redisServer实例变量，给属性设置默认值</p>
<ul>
<li>设置服务器<strong>运行id</strong></li>
<li>设置服务器<strong>默认运行频率</strong></li>
<li>设置服务器默认<strong>配置文件路径</strong></li>
<li>设置服务器<strong>运行架构</strong></li>
<li>设置服务器<strong>默认端口号</strong></li>
<li>设置默认<strong>RDB持久化条件，AOF持久化条件</strong></li>
<li>初始化<strong>LRU时钟</strong></li>
<li><strong>创建命令表</strong></li>
</ul>
<h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><p>载入用户给定的配置参数和配置文件，修改server变量属性值</p>
<h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><ul>
<li>server.<strong>clients链表</strong></li>
<li>Server.<strong>db数组</strong></li>
<li>保存频道订阅信息的server.pubsub_channels字典，保存模式订阅信息的server.pubsub_patterns字典</li>
<li>用于执行Lua脚本的<strong>Lua环境</strong>server.lua</li>
<li>慢查询日志server.slowlog</li>
</ul>
<p>给上述数据结构分配内存，设置初始化值</p>
<h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><ul>
<li>若服务器启用了AOF，使用AOF文件来还原数据库状态</li>
<li>否则，使用RDB文件还原数据库状态</li>
</ul>
<h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><h3 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h3><p><strong>旧版复制功能</strong>分为<strong>同步</strong>，和<strong>命令传播</strong></p>
<ul>
<li><strong>同步</strong>：将从数据库的状态更新至主服务器所处的数据库状态</li>
<li><strong>命令传播操作</strong>：主服务器数据被修改，让主从重新一致</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>从服务器向主服务器发送<strong>SYNC</strong>命令：</p>
<ol>
<li>从向主<strong>发送SYNC</strong></li>
<li><strong>主执行BGSAVE</strong>，后台<strong>生成RDB文件</strong>，并用<strong>缓冲区记录</strong>从现在开始执行的所有写命令</li>
<li>主执行完BGSAVE，将生成的<strong>RDB文件发送</strong>给从服务器，从服务器接收载入这个RDB文件，<strong>更新库</strong></li>
<li>主将<strong>缓冲区</strong>里所有写命令发送给从，从执行写命令，<strong>更新库</strong>。</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>将造成主从不一致的命令再发给从</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>有两种复制：</p>
<ul>
<li><strong>初次复制</strong>：从是第一次复制当前的主</li>
<li><strong>断线后复制</strong>：命令传播阶段的主从因为网络原因中断了复制，从重新连接上了主，继续复制</li>
</ul>
<p><strong>断线后复制效率低</strong>。</p>
<p>断线重连后<strong>主会发送包含全部数据的RDB文件</strong>，其中大部分数据是不必要的。</p>
<p>SYNC命令非常耗费资源：</p>
<ul>
<li>BGSAVE耗费<strong>主服务器大量的CPU、内存、磁盘IO资源</strong></li>
<li>发送RDB文件占用大量<strong>网络资源</strong>（带宽和流量）</li>
<li>载入RDB时，<strong>从服务器会阻塞</strong>，无法响应请求</li>
</ul>
<h2 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h2><p>从redis2.8开始，用<strong>PSYNC命令代替SYNC命令</strong></p>
<p>两种模式：</p>
<ul>
<li><strong>完整重同步</strong>：执行步骤和SYNC 一样</li>
<li><strong>部分重同步</strong>： 断线重连后，主服务器<strong>只发送断线期间的写命令</strong>给从服务器</li>
</ul>
<h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主从分别维护<strong>复制偏移量</strong></p>
<ul>
<li>主向从传播N字节数据，偏移量+N</li>
<li>从接收N字节数据，偏移量+N</li>
</ul>
<p><strong>对比复制偏移量，就可知道是否主从一致</strong></p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>是由<strong>主服务器维护</strong>的<strong>固定长度的队列</strong>。保存<strong>最近传播的写命令</strong>和相应<strong>复制偏移量</strong>。大小默认为1MB。</p>
<p>命令传播时，将写命令入队</p>
<p>断线重连时，主服务器根据<strong>PSYNC命令里从服务器的复制偏移量</strong>offset决定是否完整重同步：</p>
<ul>
<li>若<strong>offset</strong>之后的数据<strong>仍然存在在复制积压缓冲区</strong>，部分重同步</li>
<li>若<strong>offset</strong>之后的数据已经<strong>不存在于复制积压缓冲区</strong>，完整重同步</li>
</ul>
<h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>主从都有运行ID</p>
<p>从对主初次复制时，主将自己对运行ID发给从。</p>
<p><strong>从断线重连时，发送自己保存的主ID</strong>。</p>
<ul>
<li>若当前主服务器就是之前保存对主服务器，可以继续尝试部分重同步</li>
<li>否则，就是一个新的主服务器，进行完整重同步</li>
</ul>
<h2 id="PSYNC命令实现"><a href="#PSYNC命令实现" class="headerlink" title="PSYNC命令实现"></a>PSYNC命令实现</h2><p><strong>两种调用方式</strong>：</p>
<ul>
<li>从服务器<strong>还未复制过</strong>任何主服务器，<strong>PSYNC ? -1,主动请求完整重复制</strong></li>
<li>否则，<strong>PSYNC <runid> <offset></strong>. runid是保存的上次主服务器运行id，offset是从服务器当前复制偏移量</li>
</ul>
<p><strong>三种回复</strong>：</p>
<ul>
<li><strong>+FULLRESYNC <runid> <offset> 完整重同步</strong>。从<strong>保存主的runid</strong>, 将<strong>主的offset</strong>作为自己的offset</li>
<li><strong>+CONTINUE 部分重同步</strong>，从服务器等就行了</li>
<li><strong>-ERR</strong> 主服务器版本低于2.8，不识别PSYNC命令</li>
</ul>
<h2 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h2><p>向从服务器发送<strong>SLAVEOF</strong>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>从服务器将<strong>master ip 和master port保存</strong>到服务器状态的masterhost和masterport</p>
</li>
<li><p>建立和主服务器的<strong>套接字连接</strong></p>
</li>
<li><p><strong>从发送PING命令</strong>，检查套接字读写状态，检查主服务器是否能正常处理请求</p>
</li>
<li><p>收到主发的PONG回复后</p>
<p>4.1    <strong>从</strong>设置了<strong>masterauth</strong>, 就进行身份验证。<strong>从发送AUTH</strong> <masterauth>.</p>
<p>​    4.1.1 若<strong>主</strong>的<strong>requirepass</strong>没有设置，返回<strong>no password is set</strong>错误</p>
<p>​    4.1.2 否则，看requirepass是否和从的masterauth相同</p>
<p>4.2    否则，不进行身份验证</p>
<p>​    4.2.1 若主设置了requirepass，主返回NOAUTH错误</p>
<p>​    4.2.2 否则继续复制</p>
</li>
<li><p>发送端口信息。从给主发<code>REPLCONF listening-port &lt;port number&gt;</code>， <strong>发送自己的监听端口号</strong></p>
</li>
<li><p>同步。<strong>从向主发送PSYNC命令</strong>，执行同步操作。</p>
<p>同步前，从是主的客户端，从向主发命令。同步后，主也会成为从的客户端，给从发命令。因此，<strong>同步后，主从双方都是对方的客户端</strong>，可以<strong>互相发命令和命令回复</strong>。</p>
</li>
<li><p>命令传播</p>
</li>
</ol>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>命令传播阶段，从服务器每秒一次给主服务器发送命令：<code>REPLCONF ACK &lt;replication_offset&gt;</code> ,发送复制偏移量</p>
<p>作用：</p>
<ul>
<li>检测主从<strong>网络状态</strong></li>
<li>辅助实现<strong>min-slaves</strong>选项</li>
<li><strong>检测命令丢失</strong></li>
</ul>
<h3 id="检测主从网络状态"><a href="#检测主从网络状态" class="headerlink" title="检测主从网络状态"></a>检测主从网络状态</h3><p>如果主服务器超过一秒没有接收到REPLCONF ACK，则连接出问题了</p>
<h3 id="辅助实现min-slaves选项"><a href="#辅助实现min-slaves选项" class="headerlink" title="辅助实现min slaves选项"></a>辅助实现min slaves选项</h3><p><strong>min-slaves-to-write, min-slaves-max-lag</strong>可以<strong>防止主服务器在不安全的情况下执行写命令</strong></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>当<strong>从服务器&lt;=3</strong>个，或<strong>3个从服务器的延迟lag值</strong>（距离从上一次发ACK的时间）都<strong>&gt;=10秒</strong>，主服务器拒绝写命令</p>
<h3 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h3><p>如果主传播的写命令丢失，<strong>从服务器ACK的复制偏移量会小于主服务器的复制偏移量</strong>。主就根据从的复制偏移量，在复制积压缓冲区找到缺少的数据，重新发送。</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>Redis的高可用解决方案。</p>
<p>哨兵系统可以监视任意多个主服务器及从属服务器，当某个主服务器下线时，将其某个从属服务器升级为主服务器。</p>
<p><strong>故障转移操作</strong>：</p>
<ul>
<li>挑选一个从服务器，将其升级</li>
<li>向其他从服务器发送复制指令，让他们成为新的主服务器的从服务器。</li>
<li>继续监视已经下线的主服务器，若其重新上线，将其设置为新主服务器的从服务器</li>
</ul>
<h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><figure class="highlight plain"><figcaption><span>/path/to/your/sentinel.conf```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;redis-server &#x2F;path&#x2F;to&#x2F;your&#x2F;sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化服务器</strong></li>
<li>将普通redis服务器的<strong>代码替换</strong>成sentinel专用代码</li>
<li><strong>初始化sentinel状态</strong></li>
<li><strong>初始化sentinel监视主服务器列表</strong></li>
<li>创建<strong>连向主服务器</strong>的网络连接</li>
</ul>
<h3 id="初始化服务器-1"><a href="#初始化服务器-1" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>sentinel初始化时不载入RDB文件或者AOF文件，其他都和初始化普通服务器一样</p>
<h3 id="使用sentinel专用代码"><a href="#使用sentinel专用代码" class="headerlink" title="使用sentinel专用代码"></a>使用sentinel专用代码</h3><p>比如，普通服务器使用<strong>REDIS_SERVERPORT</strong>作为<strong>服务器端口</strong>，sentinel使用<strong>REDIS_SENTINEL_PORT</strong>作为服务器端口。</p>
<h3 id="初始化sentinel状态"><a href="#初始化sentinel状态" class="headerlink" title="初始化sentinel状态"></a>初始化sentinel状态</h3><p>初始化<strong>sentinelState结构</strong>，保存服务器中和sentinel功能有关的状态。一般状态仍由redisServer结构保存</p>
<h3 id="初始化sentinel状态的masters属性"><a href="#初始化sentinel状态的masters属性" class="headerlink" title="初始化sentinel状态的masters属性"></a>初始化sentinel状态的masters属性</h3><p>sentinel结构的masters字典记录了所有被监视的主服务器信息</p>
<ul>
<li>字典<strong>键是主服务器名字</strong></li>
<li><strong>值</strong>是被监视主服务器对应的<strong>sentinelRedisInstance</strong>结构</li>
</ul>
<h3 id="创建连接主服务器的网络连接"><a href="#创建连接主服务器的网络连接" class="headerlink" title="创建连接主服务器的网络连接"></a>创建连接主服务器的网络连接</h3><p>对每个主服务器，sentinel创建<strong>两个异步网络连接</strong></p>
<ul>
<li><strong>命令连接</strong>：用于向主服务器发送命令，接收命令回复</li>
<li><strong>订阅连接</strong>：订阅主服务器的<em>sentinel_</em>:hello频道</li>
</ul>
<p>为什么两个异步连接：</p>
<ul>
<li><strong>发布订阅功能，发送的信息不会被保存</strong>在服务器里。如果客户端不在线，客户端就会丢失这个信息。所以专门用一个<strong>订阅连接来接收</strong></li>
<li>sentinel必须<strong>发送命令</strong></li>
<li>需要<strong>与多个实例创建多个网络连接</strong>，因此是异步的。</li>
</ul>
<h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h2><p>sentinel默认<strong>通过命令连接</strong>，<strong>每10秒一次</strong>向被监视的主服务器<strong>发送INFO命令</strong>，分析回复来获取该主服务器当前信息</p>
<ul>
<li>Run_id域记录的<strong>服务器运行id</strong>，role域记录的<strong>服务器角色</strong></li>
<li>主服务器下所有<strong>从服务器信息</strong></li>
</ul>
<p>通过<strong>run_id和role</strong>，sentinel<strong>更新主服务器的实例结构</strong>。</p>
<p>通过<strong>从服务器信息</strong>，更新主服务器实例结构的<strong>slaves字典</strong></p>
<h2 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h2><p>sentinel发现<strong>有新的从服务器</strong>时，会创建连接到从服务器的<strong>命令连接和订阅连接</strong></p>
<p>连接建立后，每十秒一次<strong>向从服务器发送INFO命令</strong></p>
<h2 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h2><p>通过<strong>命令连接</strong>，向所有被监视的主从发送<code>PUBLISH  __sentinel__:hello &lt;s_ip&gt; &lt;s_port&gt; &lt;s_runid&gt; &lt;s_epoch&gt; &lt;m_name&gt; &lt;m_ip&gt; &lt;m_port&gt; &lt;m_epoch&gt;</code></p>
<h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>通过<strong>订阅连接</strong>，向服务器发送<code>SUBSCRIBE  __sentinel__:hello</code></p>
<p>对<strong>sentinel hello</strong>的订阅一直持续到连接断开</p>
<p>总结：</p>
<ul>
<li>Sentinel<strong>通过命令连接发送</strong>信息到服务器频道（sentinel hello）</li>
<li>sentinel<strong>通过订阅连接</strong>从服务器频道中<strong>接收</strong>信息(sentinel hello)。</li>
</ul>
<p>一个sentinel给服务器发送的信息，<u>会被其他监视这个服务器的sentinel接收到</u>，用于更新其他sentinel的对服务器的认知</p>
<h3 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h3><p>sentinel创建的主服务器实例结构里，sentinels字典<strong>保存了所有监视这个服务器的sentinel</strong></p>
<ul>
<li>sentinels字典键：ip:port.</li>
<li>sentinels字典值：键所对应的sentinel实例结构</li>
</ul>
<p>当一个sentinel（目标sentinel）接收到其他sentinel（目标sentinel）发送的信息时，目标sentinel会在自己的s entinel状态的masters字典中查找<strong>主服务器实例结构，更新</strong>，然后检查主服务器实例结构的<strong>sentinels字典，更新。</strong></p>
<h3 id="和其他sentinel的命令连接"><a href="#和其他sentinel的命令连接" class="headerlink" title="和其他sentinel的命令连接"></a>和其他sentinel的命令连接</h3><p>当sentinel发现其他sentinel时，也会创建<strong>和sentinel的命令连接</strong></p>
<p><strong>sentinel之间不会创建订阅连接</strong>，原因：</p>
<ul>
<li>sentinel通过<strong>订阅连接</strong>来接收服务器信息来<strong>发现未知sentinel</strong>，已知sentinel之间只使用命令连接</li>
</ul>
<h2 id="检查主观下线状态"><a href="#检查主观下线状态" class="headerlink" title="检查主观下线状态"></a>检查主观下线状态</h2><p>sentinel每秒一次向和他连接的所有实例（服务器，sentinel）发送PING，通过返回的PING回复判断是否在线</p>
<h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>判断为主观下线后，<strong>向其他sentinel询问</strong>，是否认为主服务器下线（主观或客观）。得到<strong>足够数量的已下线判断</strong>后，将主服务器判定为客观下线，并<strong>对主服务器进行故障转移</strong></p>
<ol>
<li><p><code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt;（sentinel当前的配置纪元） &lt;runid&gt;（sentinel的运行ID 为*表示检查是否下线，为源sentinel runid则用于选举领头sentinel）</code>询问sentinel是否同意主服务器下线</p>
</li>
<li><p>回复<code>Multi Bulk &lt;down_state&gt; &lt;leader_runid&gt; &lt;leader_epoch&gt;</code></p>
</li>
<li><p>判断客观下线后，将<strong>主服务器实例结构</strong>的<strong>flags属性的SRI_O_DOWN</strong>标识打开，表示已经进入客观下线</p>
</li>
</ol>
<p><strong>不同sentinel判断客观下线的标准不同</strong></p>
<h2 id="选举领头sentinel"><a href="#选举领头sentinel" class="headerlink" title="选举领头sentinel"></a>选举领头sentinel</h2><p>当一个主服务器被判断为<strong>客观下线</strong>时，所有sentinel<strong>选举出一个领头sentinel</strong>，进行<strong>故障转移操作</strong></p>
<ul>
<li>每次选举之后，sentinel的配置纪元都会自增一次。</li>
<li><strong>源sentinel</strong>向目的sentinel发送<code>SENTINEL is-master-down-by-addr</code>将<strong>runid参数设置为源sentinel的runid</strong>，要求目标sentinel<strong>将局部领头设置为自己</strong>。先到先得。一旦被设置，同纪元内不能再更改</li>
<li><strong>目标sentinel</strong>接收到<code>SENTINEL is-master-down-by-addr</code>后，<strong>返回命令回复</strong>，回复中的<strong>leader_runid</strong>和<strong>leader_epoch</strong>记录目标sentinel的局部领头sentinel和配置纪元</li>
<li><strong>源sentinel检查leader_epoch</strong>的值和自己的配置纪元是否相同，若相同，继续<strong>检查leader_runid</strong>的值。一致，则变成该目标sentinel的局部领头sentinel</li>
<li>成为<strong>超过半数的sentinel的局部领头sentinel</strong>，就会成为领头sentinel</li>
</ul>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><ol>
<li>从已下线主服务器的所有从服务器<strong>挑选出一个从服务器</strong>，将其<strong>升级</strong>为主服务器</li>
<li>让已下线主服务器属下的所有从服务器改为<strong>复制新的主服务器</strong></li>
<li>将已下线主服务器设为<strong>新的主服务器的从服务器。</strong></li>
</ol>
<h3 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h3><ul>
<li>删除所有<strong>下线或断线</strong>的从服务器</li>
<li>删除所有<strong>5秒内没有回复过领头sentinel</strong> INFO命令的从服务器</li>
<li>删除所有与<strong>已下线主服务器连接断开</strong>超过down-after-milliseconds * 10毫秒的从服务器</li>
<li>根据从服务器<strong>优先级</strong>排序，选最高优先级，<strong>复制偏移量</strong>最大的从服务器</li>
</ul>
<p>领头sentinel向被选中的从服务器<strong>发送SLAVEOF no one</strong>, 然后每十秒发送一次<strong>INFO</strong>，观察回复中的<strong>role</strong>,看是否成功升级</p>
<h3 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h3><p>向从服务器发送<strong>SLAVEOF</strong></p>
<h3 id="将旧的主服务器变成从服务器"><a href="#将旧的主服务器变成从服务器" class="headerlink" title="将旧的主服务器变成从服务器"></a>将旧的主服务器变成从服务器</h3><p>向旧主服务器发送<strong>SLAVEOF</strong></p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>连接各节点<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> ,让node节点和ip port指定节点握手。握手成功，两个节点就在一个集群里</p>
<figure class="highlight plain"><figcaption><span>NODES```查看当前集群所有节点</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 启动节点</span><br><span class="line"></span><br><span class="line">节点就是一个运行在**集群模式下的redis服务器**。</span><br><span class="line"></span><br><span class="line">### 集群数据结构</span><br><span class="line"></span><br><span class="line">**clusterNode**结构保存一个节点的当前状态，创建时间、名字、配置纪元、IP、端口号等</span><br><span class="line"></span><br><span class="line">每个节点有自己的clusterNode结构，也有别的节点的clusterNode结构</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">struct clusterNode &#123;</span><br><span class="line">  ...</span><br><span class="line">  mstime_t ctime;</span><br><span class="line">  int flags;</span><br><span class="line">  uint64_t configEpoch; &#x2F;&#x2F;当前配置纪元，用于实现故障转移</span><br><span class="line">  char ip[IP_LEN];</span><br><span class="line">  int port;</span><br><span class="line">  clusterLink *link; &#x2F;&#x2F;保存连接节点的信息</span><br><span class="line">&#125;</span><br><span class="line">struct clusterLink &#123;</span><br><span class="line">  mstime_t ctime;</span><br><span class="line">  int fd; &#x2F;&#x2F;TCP 套接字描述符</span><br><span class="line">  sds sndbuf; &#x2F;&#x2F;输出缓冲区</span><br><span class="line">  sds rcvbuf; &#x2F;&#x2F;输入缓冲区</span><br><span class="line">  struct clusterNode *node; &#x2F;&#x2F;与这个连接相关联的节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redisClient结构也有套接字描述符，输入输出缓冲区，clusterLink也有。</p>
<p>redisClient用来连接客户端，<strong>clusterLink</strong>用来连接节点</p>
<p><strong>clusterState</strong>保存集群状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">  <span class="comment">// 指向当前节点</span></span><br><span class="line">  clusterNode *myself;</span><br><span class="line">  <span class="comment">// 集群当前配置纪元，用于实现故障转移</span></span><br><span class="line">  <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">  <span class="comment">// 是否在线</span></span><br><span class="line">  <span class="keyword">int</span> state;</span><br><span class="line">  <span class="comment">// 集群中至少处理着一个槽节点的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">  <span class="comment">// 集群节点名单.键为节点名字，值为clusterNode</span></span><br><span class="line">  dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2314.37.06.png" style="zoom:50%;" />

<h3 id="CLUSTER-MEET的实现"><a href="#CLUSTER-MEET的实现" class="headerlink" title="CLUSTER MEET的实现"></a>CLUSTER MEET的实现</h3><p>B给A发CLUSTER MEET, A会把B加入集群</p>
<p>一次<strong>握手</strong>：</p>
<ol>
<li>A给B创建一个clusterNode结构，并添加到自己的clusterState.nodes字典</li>
<li>A根据CLUSTER MEET里的ip port,向B发送MEET消息</li>
<li>B接收到MEET，给A创建一个clusterNode, 添加到自己的clusterState.nodes字典</li>
<li>B给A回复PONG</li>
<li>A返回PING</li>
<li>握手完成</li>
</ol>
<h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p><strong>分片</strong>保存键值对。整个数据库分为<strong>16384个槽，每个键都属于一个槽</strong>，每个节点可以处理0～16384个槽。</p>
<p>若库中的16384个槽都有节点在处理，集群处于上线状态，否则，集群处于下线状态。</p>
<p>向节点发送CLUSTER ADDSLOTS，将槽指派给节点。</p>
<h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><p>clusterNode结构的slots属性（二进制位数组）和numslot属性</p>
<h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><p>clusterState的slots数组</p>
<h2 id="集群中执行命令"><a href="#集群中执行命令" class="headerlink" title="集群中执行命令"></a>集群中执行命令</h2><p>对所有16384个槽都指派之后，集群会进入上线状态，客户端就可以向集群中的节点发送命令了。</p>
<p>返回<strong>MOVED错误</strong>让客户端redirect到正确节点，如果不是自己的槽</p>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2411.41.04.png" style="zoom:50%;" />

<h3 id="计算键属于那个槽"><a href="#计算键属于那个槽" class="headerlink" title="计算键属于那个槽"></a>计算键属于那个槽</h3><figure class="highlight plain"><figcaption><span>& 16383```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 判断是不是自己的槽</span><br><span class="line"></span><br><span class="line">检查clusterState.slots数组</span><br><span class="line"></span><br><span class="line">### MOVED错误</span><br><span class="line"></span><br><span class="line">指引客户端转向负责节点</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<h2 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h2><p><strong>节点只能使用0号数据库</strong>，单机服务器没有这个限制</p>
<p>保存<strong>槽和键的关系</strong>： clusterState结构的<strong>slots_to_keys跳跃表</strong>，<strong>分值是槽号，成员是一个数据库键</strong></p>
<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>将已经指派给一个节点的<strong>槽改为指派给另一个节点</strong></p>
<p>可以<strong>在线进行</strong>，不要求集群下线</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>redis的<strong>集群管理软件redis_trib</strong>负责执行</p>
<ol>
<li>redis_trib对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>,让目标节点准备好导入属于槽的键值对</li>
<li>对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>，让源节点准备好</li>
<li>向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt;  &lt;count&gt;</code>，获得slot上的键名</li>
<li>对每个键名，向源节点发送<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>, 迁移键</li>
<li>向集群任意节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>，通知这个槽点已经被改变，这个消息会传遍整个集群</li>
</ol>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2412.02.36.png" style="zoom:50%;" />

<h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2412.03.57.png" style="zoom:50%;" />

<p>当客户端向源节点<strong>查询某个属于正在迁移槽的键</strong>时</p>
<h3 id="ASK错误和MOVED错误区别"><a href="#ASK错误和MOVED错误区别" class="headerlink" title="ASK错误和MOVED错误区别"></a>ASK错误和MOVED错误区别</h3><ul>
<li><strong>MOVED错误</strong>后，以后<strong>次次转向</strong>。客户端会把请求发给MOVED错误指向的节点</li>
<li><strong>ASK错误</strong>后，<strong>只转向一次</strong>，之后客户端还是会把请求发给当前正在转移键的节点</li>
</ul>
<h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>集群分为主节点和从节点，<strong>主节点用于处理槽</strong>。<strong>从节点用于复制某个主节点</strong>，并在主节点下线时，代替主节点</p>
<p>某主节点下线，其他主节点从他的从节点中选出一个成为新的主节点</p>
<h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><figure class="highlight plain"><figcaption><span>REPLICATE <node_id>``` 让接收命令的节点成为指定节点的从节点，并开始复制</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 该节点查找自己的clusterState.nodes字典，找到对应node_id的clusterNode,将自己的clusterState.myself.slaveof指向它</span><br><span class="line">2. 修改自己clusterState.myself.flags属性，REDIS_NODE_MASTER变成REDIS_NODE_SLAVE</span><br><span class="line">3. 调用复制代码，对主节点进行复制。向从节点发送&#96;&#96;&#96;SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</span><br></pre></td></tr></table></figure>

<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>每个节点定期给其他节点发送PING，若规定时间内未收到PONG,标记为<strong>疑似下线PFAIL</strong></p>
<p>当主节点A得知主节点B认为主节点C疑似下线了，A会在自己的clusterState.nodes字典里找到C的clusterNode结构，将B的下线报告添加到C的fail_reports链表里</p>
<p>如果<strong>半数以上主节点</strong>都将某个主节点<strong>报告为疑似下线</strong>，就将它<strong>标记为已下线</strong></p>
<h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>从节点发现自己的主节点下线时，进行故障转移</p>
<ol>
<li>复制该主节点的从节点中，<strong>一个从节点A被选中</strong></li>
<li>A<strong>执行SLAVEOF no one</strong>，成为主节点</li>
<li>A撤销所有对旧主节点的<strong>槽指派</strong>，并全部指派给自己</li>
<li>A<strong>向集群广播PONG</strong>，通知其他节点</li>
<li>A接收自己负责槽的<strong>命令请求</strong></li>
</ol>
<h3 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h3><ol>
<li>集群某个节点开始一场故障转移，集群<strong>配置纪元加一</strong></li>
<li>对每个配置纪元，每个复制处理槽点主节点都有一次投票机会。<strong>先向主节点要求投票的从节点先得到这一票</strong>，并收到CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息</li>
<li>从节点发现自己的主节点下线时，向集群广播CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST,要求所有主节点给自己投票</li>
<li><strong>收到&gt;=N/2+1张ACK票，从节点当选</strong></li>
<li>若没有选出，进入新的配置纪元，再次选举</li>
</ol>
<p>类似<strong>选举领头Sentinel</strong>，都是<strong>基于Raft算法的领头选举</strong></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><ul>
<li><strong>MEET消息</strong>：请求接受者加入到发送者所在集群</li>
<li><strong>PING消息</strong>：<ul>
<li>随机选5个节点，对最长时间没有发送过PING的发送PING</li>
<li>若距离最后一次收到某节点的PONG时间超过cluster-node-timeout设置值一半，发送PING</li>
</ul>
</li>
<li><strong>PONG消息</strong>：回复PING，故障转移后广播</li>
<li><strong>FAIL消息</strong>：A判断B进入FAIL状态后，向集群广播关于B的FAIL消息</li>
<li><strong>PUBLISH消息</strong>：节点接收到一个PUBLISH命令，执行这个命令，并再广播一条PUBLISH消息，所有接收到这条PUBLISH的节点都会再执行一遍</li>
</ul>
<h1 id="独立功能"><a href="#独立功能" class="headerlink" title="独立功能"></a>独立功能</h1><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2415.18.43.png" style="zoom:50%;" />

<ul>
<li><strong>SUBSCRIBE</strong>: 消息会被发送给<strong>频道的订阅者</strong></li>
<li><strong>PSUBSCRIBE</strong>:消息会被发送给<strong>频道的订阅者</strong>和<strong>频道匹配的模式的订阅者</strong></li>
</ul>
<h3 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h3><p>订阅关系保存在服务器状态<strong>redisServer</strong>的<strong>pubsub_channels字典</strong>里。<strong>键：频道，值：客户端链表</strong></p>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2415.25.15.png" style="zoom:50%;" />

<h4 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h4><p><strong>SUBSCRIBE</strong></p>
<ul>
<li>频道已经有其他订阅者，将客户端添加到链表尾部</li>
<li>否则，创建频道键，值为空链表，将客户端添加到链表</li>
</ul>
<h4 id="退订频道"><a href="#退订频道" class="headerlink" title="退订频道"></a>退订频道</h4><p><strong>UNSUBSCRIBE</strong></p>
<ul>
<li>删除链表中的客户端</li>
<li>若变成空链表，删除频道键</li>
</ul>
<h3 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h3><p>订阅关系保存在服务器状态<strong>redisServer</strong>的<strong>pubsub_patterns链表</strong>里。每个节点都是一个pubsubPattern结构，pattern记录模式，client记录客户端</p>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2415.30.46.png" style="zoom:50%;" />

<h4 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h4><p><strong>PSUBSCRIBE</strong></p>
<ul>
<li>创建pubsubPattern结构，设置属性</li>
<li>添加到链表尾部</li>
</ul>
<h4 id="退订模式"><a href="#退订模式" class="headerlink" title="退订模式"></a>退订模式</h4><p><strong>PUNSUBSCRIBE</strong></p>
<ul>
<li>在pubsubPattern中删除相应结构</li>
</ul>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>当redis客户端执行<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code></p>
<ul>
<li>服务器将消息发送给channel频道的订阅者</li>
<li>若有模式匹配，将<strong>消息发送给模式的订阅者</strong></li>
</ul>
<p>通过查找pubsub_channels 和pubsub_patterns，发送消息</p>
<h2 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h2><p><strong>PUBSUB CHANNELS [pattern]</strong>返回服务器当前被订阅的频道或与模式匹配的频道（遍历pubs_channels的所有键）</p>
<p><strong>PUBSUB NUMSUB [channel-1 channel-2…],</strong> 返回频道的订阅者数量（查找pubs_channels）</p>
<p><strong>PUBSUB NUMPAT</strong>返回当前被订阅模式的数量（pubsub_patterns链表的长度）</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务<strong>将命令打包</strong>，<strong>一次性按顺序执行</strong>。并且事务执行期间，服务器不会中断</p>
<p>MULTI命令开始，EXEC命令结束并提交</p>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2510.14.52.png" style="zoom:50%;" />

<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><ul>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p><strong>MULTI</strong>标志事务的开始，将客户端<strong>从非事务状态切换到事务状态</strong>。在flags标志中<strong>打开REDIS_MULTI标识</strong></p>
<h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><ul>
<li><p>如果是<strong>EXEC DISCARD WATCH MULTI</strong>,立即执行</p>
</li>
<li><p>否则，将命令<strong>放入一个事务队列</strong>里，向客户端<strong>返回QUEUED回复</strong></p>
</li>
</ul>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2510.34.57.png" style="zoom:50%;" />

<h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>客户端状态的<strong>mstate保存事务状态</strong></p>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2510.37.04.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">	<span class="comment">// 事务队列</span></span><br><span class="line">  multiCmd *commands;</span><br><span class="line">  <span class="comment">// 已入队命令计数</span></span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">  <span class="comment">//参数</span></span><br><span class="line">  robj **argv;</span><br><span class="line">  <span class="comment">//参数数量</span></span><br><span class="line">  <span class="keyword">int</span> argc;</span><br><span class="line">  <span class="comment">//命令指针，指向命令实现函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2510.41.22.png" style="zoom:50%;" />

<h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>服务端遍历客户端事务队列，执行队列中的命令，将结果全部返回</p>
<h2 id="WATCH的实现"><a href="#WATCH的实现" class="headerlink" title="WATCH的实现"></a>WATCH的实现</h2><p><strong>乐观锁</strong>。在EXEC之前，<strong>监视任意数量的数据库键</strong>，并在EXEC执行时，检查是否有被<strong>监视的键被修改</strong>。如果是，服务器<strong>拒绝执行事务</strong>，并向客户端返回代表事务<strong>执行失败的空回复</strong>。</p>
<h3 id="WATCH监视数据库键"><a href="#WATCH监视数据库键" class="headerlink" title="WATCH监视数据库键"></a>WATCH监视数据库键</h3><p>每个redis数据库都保存一个<strong>watched_keys字典</strong>。<strong>键：某个被WATCH命令监视的数据库键，值：监视该键的客户端链表</strong></p>
<img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2511.04.43.png" style="zoom:50%;" />

<h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库<strong>修改的命令</strong>（SET，LPUSH，SADD…），<strong>执行后会检查watched_keys字典</strong>，看该键是否被监视。若是，<strong>修改对应客户端的REDIS_DIRTY_CAS标识</strong>，表示该客户端的事务安全性被破坏</p>
<h3 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h3><img src="/Users/yesun/Documents/学习/笔记/图片/redis图片/截屏2020-04-2511.08.20.png" style="zoom:50%;" />

<p>若客户端的事务安全性以及被破坏，不再执行他的任何事务</p>
<h2 id="ACID性质"><a href="#ACID性质" class="headerlink" title="ACID性质"></a>ACID性质</h2><p>Redis下，事务都有ACI，当redis运行在特定的持久化模式时，也有D</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>redis<strong>不支持事务回滚</strong>。事务队列里<strong>某个命令执行出错</strong>，<strong>事务还会继续执行</strong></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><h4 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h4><p>若一个事务<strong>入队命令时</strong>，出现<strong>命令不存在</strong>或<strong>格式不正确</strong>，redis拒绝执行这个事务</p>
<h4 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h4><p>只会在命令执行时被触发的错误。</p>
<p>出错的命令会被服务器识别，进行<strong>相应的错误处理</strong>，不影响事务一致性</p>
<h4 id="服务器停机"><a href="#服务器停机" class="headerlink" title="服务器停机"></a>服务器停机</h4><p>如果redis在执行事务中停机：</p>
<ul>
<li>无持久化模式下，重启后数据库空白，一致</li>
<li>RDB模式下，仍然一致，可以根据现有RDB文件恢复数据库</li>
<li>AOF模式下，仍然一致。可以根据AOF文件恢复</li>
</ul>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>单线程</strong>执行事务，事务<strong>不会被中断</strong>，<strong>串行</strong>执行。具有隔离性</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>AOF模式下，appendfsync选项为always，事务具有耐久性</p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2020 - 叶子 </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm" target="_blank" rel="noopener">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>